{"version":3,"sources":["esprima.js"],"names":[],"mappings":"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","file":"esprima-compiled.js","sourcesContent":["/*\n  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n(function (root, factory) {\n    'use strict';\n\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n    // Rhino, and plain browser loading.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define(['exports'], factory);\n    } else if (typeof exports !== 'undefined') {\n        factory(exports);\n    } else {\n        factory((root.esprima = {}));\n    }\n}(this, function (exports) {\n    'use strict';\n\n    var Token,\n        TokenName,\n        FnExprTokens,\n        Syntax,\n        PropertyKind,\n        Messages,\n        Regex,\n        SyntaxTreeDelegate,\n        XHTMLEntities,\n        ClassPropertyType,\n        source,\n        strict,\n        index,\n        lineNumber,\n        lineStart,\n        length,\n        delegate,\n        lookahead,\n        state,\n        extra;\n\n    Token = {\n        BooleanLiteral: 1,\n        EOF: 2,\n        Identifier: 3,\n        Keyword: 4,\n        NullLiteral: 5,\n        NumericLiteral: 6,\n        Punctuator: 7,\n        StringLiteral: 8,\n        RegularExpression: 9,\n        Template: 10,\n        JSXIdentifier: 11,\n        JSXText: 12\n    };\n\n    TokenName = {};\n    TokenName[Token.BooleanLiteral] = 'Boolean';\n    TokenName[Token.EOF] = '<end>';\n    TokenName[Token.Identifier] = 'Identifier';\n    TokenName[Token.Keyword] = 'Keyword';\n    TokenName[Token.NullLiteral] = 'Null';\n    TokenName[Token.NumericLiteral] = 'Numeric';\n    TokenName[Token.Punctuator] = 'Punctuator';\n    TokenName[Token.StringLiteral] = 'String';\n    TokenName[Token.JSXIdentifier] = 'JSXIdentifier';\n    TokenName[Token.JSXText] = 'JSXText';\n    TokenName[Token.RegularExpression] = 'RegularExpression';\n    TokenName[Token.Template] = 'Template';\n\n    // A function following one of those tokens is an expression.\n    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',\n                    'return', 'case', 'delete', 'throw', 'void',\n                    // assignment operators\n                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',\n                    '&=', '|=', '^=', ',',\n                    // binary/unary operators\n                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',\n                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',\n                    '<=', '<', '>', '!=', '!=='];\n\n    Syntax = {\n        AnyTypeAnnotation: 'AnyTypeAnnotation',\n        ArrayExpression: 'ArrayExpression',\n        ArrayPattern: 'ArrayPattern',\n        ArrayTypeAnnotation: 'ArrayTypeAnnotation',\n        ArrowFunctionExpression: 'ArrowFunctionExpression',\n        AssignmentExpression: 'AssignmentExpression',\n        BinaryExpression: 'BinaryExpression',\n        BlockStatement: 'BlockStatement',\n        BooleanTypeAnnotation: 'BooleanTypeAnnotation',\n        BreakStatement: 'BreakStatement',\n        CallExpression: 'CallExpression',\n        CatchClause: 'CatchClause',\n        ClassBody: 'ClassBody',\n        ClassDeclaration: 'ClassDeclaration',\n        ClassExpression: 'ClassExpression',\n        ClassImplements: 'ClassImplements',\n        ClassProperty: 'ClassProperty',\n        ComprehensionBlock: 'ComprehensionBlock',\n        ComprehensionExpression: 'ComprehensionExpression',\n        ConditionalExpression: 'ConditionalExpression',\n        ContinueStatement: 'ContinueStatement',\n        DebuggerStatement: 'DebuggerStatement',\n        DeclareClass: 'DeclareClass',\n        DeclareFunction: 'DeclareFunction',\n        DeclareModule: 'DeclareModule',\n        DeclareVariable: 'DeclareVariable',\n        DoWhileStatement: 'DoWhileStatement',\n        EmptyStatement: 'EmptyStatement',\n        ExportDeclaration: 'ExportDeclaration',\n        ExportBatchSpecifier: 'ExportBatchSpecifier',\n        ExportSpecifier: 'ExportSpecifier',\n        ExpressionStatement: 'ExpressionStatement',\n        ForInStatement: 'ForInStatement',\n        ForOfStatement: 'ForOfStatement',\n        ForStatement: 'ForStatement',\n        FunctionDeclaration: 'FunctionDeclaration',\n        FunctionExpression: 'FunctionExpression',\n        FunctionTypeAnnotation: 'FunctionTypeAnnotation',\n        FunctionTypeParam: 'FunctionTypeParam',\n        GenericTypeAnnotation: 'GenericTypeAnnotation',\n        Identifier: 'Identifier',\n        IfStatement: 'IfStatement',\n        ImportDeclaration: 'ImportDeclaration',\n        ImportDefaultSpecifier: 'ImportDefaultSpecifier',\n        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',\n        ImportSpecifier: 'ImportSpecifier',\n        InterfaceDeclaration: 'InterfaceDeclaration',\n        InterfaceExtends: 'InterfaceExtends',\n        IntersectionTypeAnnotation: 'IntersectionTypeAnnotation',\n        LabeledStatement: 'LabeledStatement',\n        Literal: 'Literal',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        MethodDefinition: 'MethodDefinition',\n        NewExpression: 'NewExpression',\n        NullableTypeAnnotation: 'NullableTypeAnnotation',\n        NumberTypeAnnotation: 'NumberTypeAnnotation',\n        ObjectExpression: 'ObjectExpression',\n        ObjectPattern: 'ObjectPattern',\n        ObjectTypeAnnotation: 'ObjectTypeAnnotation',\n        ObjectTypeCallProperty: 'ObjectTypeCallProperty',\n        ObjectTypeIndexer: 'ObjectTypeIndexer',\n        ObjectTypeProperty: 'ObjectTypeProperty',\n        Program: 'Program',\n        Property: 'Property',\n        QualifiedTypeIdentifier: 'QualifiedTypeIdentifier',\n        ReturnStatement: 'ReturnStatement',\n        SequenceExpression: 'SequenceExpression',\n        SpreadElement: 'SpreadElement',\n        SpreadProperty: 'SpreadProperty',\n        StringLiteralTypeAnnotation: 'StringLiteralTypeAnnotation',\n        StringTypeAnnotation: 'StringTypeAnnotation',\n        SwitchCase: 'SwitchCase',\n        SwitchStatement: 'SwitchStatement',\n        TaggedTemplateExpression: 'TaggedTemplateExpression',\n        TemplateElement: 'TemplateElement',\n        TemplateLiteral: 'TemplateLiteral',\n        ThisExpression: 'ThisExpression',\n        ThrowStatement: 'ThrowStatement',\n        TupleTypeAnnotation: 'TupleTypeAnnotation',\n        TryStatement: 'TryStatement',\n        TypeAlias: 'TypeAlias',\n        TypeAnnotation: 'TypeAnnotation',\n        TypeCastExpression: 'TypeCastExpression',\n        TypeofTypeAnnotation: 'TypeofTypeAnnotation',\n        TypeParameterDeclaration: 'TypeParameterDeclaration',\n        TypeParameterInstantiation: 'TypeParameterInstantiation',\n        UnaryExpression: 'UnaryExpression',\n        UnionTypeAnnotation: 'UnionTypeAnnotation',\n        UpdateExpression: 'UpdateExpression',\n        VariableDeclaration: 'VariableDeclaration',\n        VariableDeclarator: 'VariableDeclarator',\n        VoidTypeAnnotation: 'VoidTypeAnnotation',\n        WhileStatement: 'WhileStatement',\n        WithStatement: 'WithStatement',\n        JSXIdentifier: 'JSXIdentifier',\n        JSXNamespacedName: 'JSXNamespacedName',\n        JSXMemberExpression: 'JSXMemberExpression',\n        JSXEmptyExpression: 'JSXEmptyExpression',\n        JSXExpressionContainer: 'JSXExpressionContainer',\n        JSXElement: 'JSXElement',\n        JSXClosingElement: 'JSXClosingElement',\n        JSXOpeningElement: 'JSXOpeningElement',\n        JSXAttribute: 'JSXAttribute',\n        JSXSpreadAttribute: 'JSXSpreadAttribute',\n        JSXText: 'JSXText',\n        YieldExpression: 'YieldExpression',\n        AwaitExpression: 'AwaitExpression'\n    };\n\n    PropertyKind = {\n        Data: 1,\n        Get: 2,\n        Set: 4\n    };\n\n    ClassPropertyType = {\n        'static': 'static',\n        prototype: 'prototype'\n    };\n\n    // Error messages should be identical to V8.\n    Messages = {\n        UnexpectedToken: 'Unexpected token %0',\n        UnexpectedNumber: 'Unexpected number',\n        UnexpectedString: 'Unexpected string',\n        UnexpectedIdentifier: 'Unexpected identifier',\n        UnexpectedReserved: 'Unexpected reserved word',\n        UnexpectedTemplate: 'Unexpected quasi %0',\n        UnexpectedEOS: 'Unexpected end of input',\n        NewlineAfterThrow: 'Illegal newline after throw',\n        InvalidRegExp: 'Invalid regular expression',\n        UnterminatedRegExp: 'Invalid regular expression: missing /',\n        InvalidLHSInAssignment: 'Invalid left-hand side in assignment',\n        InvalidLHSInFormalsList: 'Invalid left-hand side in formals list',\n        InvalidLHSInForIn: 'Invalid left-hand side in for-in',\n        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n        NoCatchOrFinally: 'Missing catch or finally after try',\n        UnknownLabel: 'Undefined label \\'%0\\'',\n        Redeclaration: '%0 \\'%1\\' has already been declared',\n        IllegalContinue: 'Illegal continue statement',\n        IllegalBreak: 'Illegal break statement',\n        IllegalDuplicateClassProperty: 'Illegal duplicate property in class definition',\n        IllegalClassConstructorProperty: 'Illegal constructor property in class definition',\n        IllegalReturn: 'Illegal return statement',\n        IllegalSpread: 'Illegal spread element',\n        StrictModeWith: 'Strict mode code may not include a with statement',\n        StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',\n        StrictVarName: 'Variable name may not be eval or arguments in strict mode',\n        StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',\n        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n        ParameterAfterRestParameter: 'Rest parameter must be final parameter of an argument list',\n        DefaultRestParameter: 'Rest parameter can not have a default value',\n        ElementAfterSpreadElement: 'Spread must be the final element of an element list',\n        PropertyAfterSpreadProperty: 'A rest property must be the final property of an object literal',\n        ObjectPatternAsRestParameter: 'Invalid rest parameter',\n        ObjectPatternAsSpread: 'Invalid spread argument',\n        StrictFunctionName: 'Function name may not be eval or arguments in strict mode',\n        StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',\n        StrictDelete: 'Delete of an unqualified identifier in strict mode.',\n        StrictDuplicateProperty: 'Duplicate data property in object literal not allowed in strict mode',\n        AccessorDataProperty: 'Object literal may not have data and accessor property with the same name',\n        AccessorGetSet: 'Object literal may not have multiple get/set accessors with the same name',\n        StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',\n        StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictReservedWord: 'Use of future reserved word in strict mode',\n        MissingFromClause: 'Missing from clause',\n        NoAsAfterImportNamespace: 'Missing as after import *',\n        InvalidModuleSpecifier: 'Invalid module specifier',\n        IllegalImportDeclaration: 'Illegal import declaration',\n        IllegalExportDeclaration: 'Illegal export declaration',\n        NoUninitializedConst: 'Const must be initialized',\n        ComprehensionRequiresBlock: 'Comprehension must have at least one block',\n        ComprehensionError: 'Comprehension Error',\n        EachNotAllowed: 'Each is not supported',\n        InvalidJSXAttributeValue: 'JSX value should be either an expression or a quoted JSX text',\n        ExpectedJSXClosingTag: 'Expected corresponding JSX closing tag for %0',\n        AdjacentJSXElements: 'Adjacent JSX elements must be wrapped in an enclosing tag',\n        ConfusedAboutFunctionType: 'Unexpected token =>. It looks like ' +\n            'you are trying to write a function type, but you ended up ' +\n            'writing a grouped type followed by an =>, which is a syntax ' +\n            'error. Remember, function type parameters are named so function ' +\n            'types look like (name1: type1, name2: type2) => returnType. You ' +\n            'probably wrote (type1) => returnType'\n    };\n\n    // See also tools/generate-unicode-regex.py.\n    Regex = {\n        NonAsciiIdentifierStart: new RegExp('[\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]'),\n        NonAsciiIdentifierPart: new RegExp('[\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0300-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u0483-\\u0487\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0610-\\u061a\\u0620-\\u0669\\u066e-\\u06d3\\u06d5-\\u06dc\\u06df-\\u06e8\\u06ea-\\u06fc\\u06ff\\u0710-\\u074a\\u074d-\\u07b1\\u07c0-\\u07f5\\u07fa\\u0800-\\u082d\\u0840-\\u085b\\u08a0\\u08a2-\\u08ac\\u08e4-\\u08fe\\u0900-\\u0963\\u0966-\\u096f\\u0971-\\u0977\\u0979-\\u097f\\u0981-\\u0983\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bc-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09ce\\u09d7\\u09dc\\u09dd\\u09df-\\u09e3\\u09e6-\\u09f1\\u0a01-\\u0a03\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a59-\\u0a5c\\u0a5e\\u0a66-\\u0a75\\u0a81-\\u0a83\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abc-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ad0\\u0ae0-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3c-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5c\\u0b5d\\u0b5f-\\u0b63\\u0b66-\\u0b6f\\u0b71\\u0b82\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd0\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c58\\u0c59\\u0c60-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbc-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0cde\\u0ce0-\\u0ce3\\u0ce6-\\u0cef\\u0cf1\\u0cf2\\u0d02\\u0d03\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4e\\u0d57\\u0d60-\\u0d63\\u0d66-\\u0d6f\\u0d7a-\\u0d7f\\u0d82\\u0d83\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e01-\\u0e3a\\u0e40-\\u0e4e\\u0e50-\\u0e59\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb9\\u0ebb-\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0edc-\\u0edf\\u0f00\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e-\\u0f47\\u0f49-\\u0f6c\\u0f71-\\u0f84\\u0f86-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1049\\u1050-\\u109d\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u135d-\\u135f\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176c\\u176e-\\u1770\\u1772\\u1773\\u1780-\\u17d3\\u17d7\\u17dc\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a1b\\u1a20-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1aa7\\u1b00-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1bf3\\u1c00-\\u1c37\\u1c40-\\u1c49\\u1c4d-\\u1c7d\\u1cd0-\\u1cd2\\u1cd4-\\u1cf6\\u1d00-\\u1de6\\u1dfc-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u200c\\u200d\\u203f\\u2040\\u2054\\u2071\\u207f\\u2090-\\u209c\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d7f-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2de0-\\u2dff\\u2e2f\\u3005-\\u3007\\u3021-\\u302f\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u3099\\u309a\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua62b\\ua640-\\ua66f\\ua674-\\ua67d\\ua67f-\\ua697\\ua69f-\\ua6f1\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua827\\ua840-\\ua873\\ua880-\\ua8c4\\ua8d0-\\ua8d9\\ua8e0-\\ua8f7\\ua8fb\\ua900-\\ua92d\\ua930-\\ua953\\ua960-\\ua97c\\ua980-\\ua9c0\\ua9cf-\\ua9d9\\uaa00-\\uaa36\\uaa40-\\uaa4d\\uaa50-\\uaa59\\uaa60-\\uaa76\\uaa7a\\uaa7b\\uaa80-\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaef\\uaaf2-\\uaaf6\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff10-\\uff19\\uff21-\\uff3a\\uff3f\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]'),\n        LeadingZeros: new RegExp('^0+(?!$)')\n    };\n\n    // Ensure the condition is true, otherwise throw an error.\n    // This is only to have a better contract semantic, i.e. another safety net\n    // to catch a logic error. The condition shall be fulfilled in normal case.\n    // Do NOT use this to enforce a certain condition on any user input.\n\n    function assert(condition, message) {\n        /* istanbul ignore if */\n        if (!condition) {\n            throw new Error('ASSERT: ' + message);\n        }\n    }\n\n    function StringMap() {\n        this.$data = {};\n    }\n\n    StringMap.prototype.get = function (key) {\n        key = '$' + key;\n        return this.$data[key];\n    };\n\n    StringMap.prototype.set = function (key, value) {\n        key = '$' + key;\n        this.$data[key] = value;\n        return this;\n    };\n\n    StringMap.prototype.has = function (key) {\n        key = '$' + key;\n        return Object.prototype.hasOwnProperty.call(this.$data, key);\n    };\n\n    StringMap.prototype.delete = function (key) {\n        key = '$' + key;\n        return delete this.$data[key];\n    };\n\n    function isDecimalDigit(ch) {\n        return (ch >= 48 && ch <= 57);   // 0..9\n    }\n\n    function isHexDigit(ch) {\n        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n    }\n\n    function isOctalDigit(ch) {\n        return '01234567'.indexOf(ch) >= 0;\n    }\n\n\n    // 7.2 White Space\n\n    function isWhiteSpace(ch) {\n        return (ch === 32) ||  // space\n            (ch === 9) ||      // tab\n            (ch === 0xB) ||\n            (ch === 0xC) ||\n            (ch === 0xA0) ||\n            (ch >= 0x1680 && '\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\uFEFF'.indexOf(String.fromCharCode(ch)) > 0);\n    }\n\n    // 7.3 Line Terminators\n\n    function isLineTerminator(ch) {\n        return (ch === 10) || (ch === 13) || (ch === 0x2028) || (ch === 0x2029);\n    }\n\n    // 7.6 Identifier Names and Identifiers\n\n    function isIdentifierStart(ch) {\n        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)\n            (ch >= 65 && ch <= 90) ||         // A..Z\n            (ch >= 97 && ch <= 122) ||        // a..z\n            (ch === 92) ||                    // \\ (backslash)\n            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));\n    }\n\n    function isIdentifierPart(ch) {\n        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)\n            (ch >= 65 && ch <= 90) ||         // A..Z\n            (ch >= 97 && ch <= 122) ||        // a..z\n            (ch >= 48 && ch <= 57) ||         // 0..9\n            (ch === 92) ||                    // \\ (backslash)\n            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));\n    }\n\n    // 7.6.1.2 Future Reserved Words\n\n    function isFutureReservedWord(id) {\n        switch (id) {\n        case 'class':\n        case 'enum':\n        case 'export':\n        case 'extends':\n        case 'import':\n        case 'super':\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    function isStrictModeReservedWord(id) {\n        switch (id) {\n        case 'implements':\n        case 'interface':\n        case 'package':\n        case 'private':\n        case 'protected':\n        case 'public':\n        case 'static':\n        case 'yield':\n        case 'let':\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    function isRestrictedWord(id) {\n        return id === 'eval' || id === 'arguments';\n    }\n\n    // 7.6.1.1 Keywords\n\n    function isKeyword(id) {\n        if (strict && isStrictModeReservedWord(id)) {\n            return true;\n        }\n\n        // 'const' is specialized as Keyword in V8.\n        // 'yield' is only treated as a keyword in strict mode.\n        // 'let' is for compatiblity with SpiderMonkey and ES.next.\n        // Some others are from future reserved words.\n\n        switch (id.length) {\n        case 2:\n            return (id === 'if') || (id === 'in') || (id === 'do');\n        case 3:\n            return (id === 'var') || (id === 'for') || (id === 'new') ||\n                (id === 'try') || (id === 'let');\n        case 4:\n            return (id === 'this') || (id === 'else') || (id === 'case') ||\n                (id === 'void') || (id === 'with') || (id === 'enum');\n        case 5:\n            return (id === 'while') || (id === 'break') || (id === 'catch') ||\n                (id === 'throw') || (id === 'const') ||\n                (id === 'class') || (id === 'super');\n        case 6:\n            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||\n                (id === 'switch') || (id === 'export') || (id === 'import');\n        case 7:\n            return (id === 'default') || (id === 'finally') || (id === 'extends');\n        case 8:\n            return (id === 'function') || (id === 'continue') || (id === 'debugger');\n        case 10:\n            return (id === 'instanceof');\n        default:\n            return false;\n        }\n    }\n\n    // 7.4 Comments\n\n    function addComment(type, value, start, end, loc) {\n        var comment;\n        assert(typeof start === 'number', 'Comment must have valid position');\n\n        // Because the way the actual token is scanned, often the comments\n        // (if any) are skipped twice during the lexical analysis.\n        // Thus, we need to skip adding a comment if the comment array already\n        // handled it.\n        if (state.lastCommentStart >= start) {\n            return;\n        }\n        state.lastCommentStart = start;\n\n        comment = {\n            type: type,\n            value: value\n        };\n        if (extra.range) {\n            comment.range = [start, end];\n        }\n        if (extra.loc) {\n            comment.loc = loc;\n        }\n        extra.comments.push(comment);\n        if (extra.attachComment) {\n            extra.leadingComments.push(comment);\n            extra.trailingComments.push(comment);\n        }\n    }\n\n    function skipSingleLineComment() {\n        var start, loc, ch, comment;\n\n        start = index - 2;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart - 2\n            }\n        };\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            ++index;\n            if (isLineTerminator(ch)) {\n                if (extra.comments) {\n                    comment = source.slice(start + 2, index - 1);\n                    loc.end = {\n                        line: lineNumber,\n                        column: index - lineStart - 1\n                    };\n                    addComment('Line', comment, start, index - 1, loc);\n                }\n                if (ch === 13 && source.charCodeAt(index) === 10) {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n                return;\n            }\n        }\n\n        if (extra.comments) {\n            comment = source.slice(start + 2, index);\n            loc.end = {\n                line: lineNumber,\n                column: index - lineStart\n            };\n            addComment('Line', comment, start, index, loc);\n        }\n    }\n\n    function skipMultiLineComment() {\n        var start, loc, ch, comment;\n\n        if (extra.comments) {\n            start = index - 2;\n            loc = {\n                start: {\n                    line: lineNumber,\n                    column: index - lineStart - 2\n                }\n            };\n        }\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (isLineTerminator(ch)) {\n                if (ch === 13 && source.charCodeAt(index + 1) === 10) {\n                    ++index;\n                }\n                ++lineNumber;\n                ++index;\n                lineStart = index;\n                if (index >= length) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n            } else if (ch === 42) {\n                // Block comment ends with '*/' (char #42, char #47).\n                if (source.charCodeAt(index + 1) === 47) {\n                    ++index;\n                    ++index;\n                    if (extra.comments) {\n                        comment = source.slice(start + 2, index - 2);\n                        loc.end = {\n                            line: lineNumber,\n                            column: index - lineStart\n                        };\n                        addComment('Block', comment, start, index, loc);\n                    }\n                    return;\n                }\n                ++index;\n            } else {\n                ++index;\n            }\n        }\n\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n\n    function skipComment() {\n        var ch;\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n\n            if (isWhiteSpace(ch)) {\n                ++index;\n            } else if (isLineTerminator(ch)) {\n                ++index;\n                if (ch === 13 && source.charCodeAt(index) === 10) {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n            } else if (ch === 47) { // 47 is '/'\n                ch = source.charCodeAt(index + 1);\n                if (ch === 47) {\n                    ++index;\n                    ++index;\n                    skipSingleLineComment();\n                } else if (ch === 42) {  // 42 is '*'\n                    ++index;\n                    ++index;\n                    skipMultiLineComment();\n                } else {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n    }\n\n    function scanHexEscape(prefix) {\n        var i, len, ch, code = 0;\n\n        len = (prefix === 'u') ? 4 : 2;\n        for (i = 0; i < len; ++i) {\n            if (index < length && isHexDigit(source[index])) {\n                ch = source[index++];\n                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n            } else {\n                return '';\n            }\n        }\n        return String.fromCharCode(code);\n    }\n\n    function scanUnicodeCodePointEscape() {\n        var ch, code, cu1, cu2;\n\n        ch = source[index];\n        code = 0;\n\n        // At least, one hex digit is required.\n        if (ch === '}') {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        while (index < length) {\n            ch = source[index++];\n            if (!isHexDigit(ch)) {\n                break;\n            }\n            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n        }\n\n        if (code > 0x10FFFF || ch !== '}') {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        // UTF-16 Encoding\n        if (code <= 0xFFFF) {\n            return String.fromCharCode(code);\n        }\n        cu1 = ((code - 0x10000) >> 10) + 0xD800;\n        cu2 = ((code - 0x10000) & 1023) + 0xDC00;\n        return String.fromCharCode(cu1, cu2);\n    }\n\n    function getEscapedIdentifier() {\n        var ch, id;\n\n        ch = source.charCodeAt(index++);\n        id = String.fromCharCode(ch);\n\n        // '\\u' (char #92, char #117) denotes an escaped character.\n        if (ch === 92) {\n            if (source.charCodeAt(index) !== 117) {\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n            ++index;\n            ch = scanHexEscape('u');\n            if (!ch || ch === '\\\\' || !isIdentifierStart(ch.charCodeAt(0))) {\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n            id = ch;\n        }\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (!isIdentifierPart(ch)) {\n                break;\n            }\n            ++index;\n            id += String.fromCharCode(ch);\n\n            // '\\u' (char #92, char #117) denotes an escaped character.\n            if (ch === 92) {\n                id = id.substr(0, id.length - 1);\n                if (source.charCodeAt(index) !== 117) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n                ++index;\n                ch = scanHexEscape('u');\n                if (!ch || ch === '\\\\' || !isIdentifierPart(ch.charCodeAt(0))) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n                id += ch;\n            }\n        }\n\n        return id;\n    }\n\n    function getIdentifier() {\n        var start, ch;\n\n        start = index++;\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (ch === 92) {\n                // Blackslash (char #92) marks Unicode escape sequence.\n                index = start;\n                return getEscapedIdentifier();\n            }\n            if (isIdentifierPart(ch)) {\n                ++index;\n            } else {\n                break;\n            }\n        }\n\n        return source.slice(start, index);\n    }\n\n    function scanIdentifier() {\n        var start, id, type;\n\n        start = index;\n\n        // Backslash (char #92) starts an escaped character.\n        id = (source.charCodeAt(index) === 92) ? getEscapedIdentifier() : getIdentifier();\n\n        // There is no keyword or literal with only one character.\n        // Thus, it must be an identifier.\n        if (id.length === 1) {\n            type = Token.Identifier;\n        } else if (isKeyword(id)) {\n            type = Token.Keyword;\n        } else if (id === 'null') {\n            type = Token.NullLiteral;\n        } else if (id === 'true' || id === 'false') {\n            type = Token.BooleanLiteral;\n        } else {\n            type = Token.Identifier;\n        }\n\n        return {\n            type: type,\n            value: id,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n\n    // 7.7 Punctuators\n\n    function scanPunctuator() {\n        var start = index,\n            code = source.charCodeAt(index),\n            code2,\n            ch1 = source[index],\n            ch2,\n            ch3,\n            ch4;\n\n        if (state.inJSXTag || state.inJSXChild) {\n            // Don't need to check for '{' and '}' as it's already handled\n            // correctly by default.\n            switch (code) {\n            case 60:  // <\n            case 62:  // >\n                ++index;\n                return {\n                    type: Token.Punctuator,\n                    value: String.fromCharCode(code),\n                    lineNumber: lineNumber,\n                    lineStart: lineStart,\n                    range: [start, index]\n                };\n            }\n        }\n\n        switch (code) {\n        // Check for most common single-character punctuators.\n        case 40:   // ( open bracket\n        case 41:   // ) close bracket\n        case 59:   // ; semicolon\n        case 44:   // , comma\n        case 91:   // [\n        case 93:   // ]\n        case 58:   // :\n        case 63:   // ?\n        case 126:  // ~\n            ++index;\n            if (extra.tokenize && code === 40) {\n                extra.openParenToken = extra.tokens.length;\n            }\n\n            return {\n                type: Token.Punctuator,\n                value: String.fromCharCode(code),\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n\n        case 123:  // { open curly brace\n        case 125:  // } close curly brace\n            ++index;\n            if (extra.tokenize && code === 123) {\n                extra.openCurlyToken = extra.tokens.length;\n            }\n\n            // lookahead2 function can cause tokens to be scanned twice and in doing so\n            // would wreck the curly stack by pushing the same token onto the stack twice.\n            // curlyLastIndex ensures each token is pushed or popped exactly once\n            if (index > state.curlyLastIndex) {\n                state.curlyLastIndex = index;\n                if (code === 123) {\n                    state.curlyStack.push('{');\n                } else {\n                    state.curlyStack.pop();\n                }\n            }\n\n            return {\n                type: Token.Punctuator,\n                value: String.fromCharCode(code),\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n\n        default:\n            code2 = source.charCodeAt(index + 1);\n\n            // '=' (char #61) marks an assignment or comparison operator.\n            if (code2 === 61) {\n                switch (code) {\n                case 37:  // %\n                case 38:  // &\n                case 42:  // *:\n                case 43:  // +\n                case 45:  // -\n                case 47:  // /\n                case 60:  // <\n                case 62:  // >\n                case 94:  // ^\n                case 124: // |\n                    index += 2;\n                    return {\n                        type: Token.Punctuator,\n                        value: String.fromCharCode(code) + String.fromCharCode(code2),\n                        lineNumber: lineNumber,\n                        lineStart: lineStart,\n                        range: [start, index]\n                    };\n\n                case 33: // !\n                case 61: // =\n                    index += 2;\n\n                    // !== and ===\n                    if (source.charCodeAt(index) === 61) {\n                        ++index;\n                    }\n                    return {\n                        type: Token.Punctuator,\n                        value: source.slice(start, index),\n                        lineNumber: lineNumber,\n                        lineStart: lineStart,\n                        range: [start, index]\n                    };\n                default:\n                    break;\n                }\n            }\n            break;\n        }\n\n        // Peek more characters.\n\n        ch2 = source[index + 1];\n        ch3 = source[index + 2];\n        ch4 = source[index + 3];\n\n        // 4-character punctuator: >>>=\n\n        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {\n            if (ch4 === '=') {\n                index += 4;\n                return {\n                    type: Token.Punctuator,\n                    value: '>>>=',\n                    lineNumber: lineNumber,\n                    lineStart: lineStart,\n                    range: [start, index]\n                };\n            }\n        }\n\n        // 3-character punctuators: === !== >>> <<= >>=\n\n        if (ch1 === '>' && ch2 === '>' && ch3 === '>' && !state.inType) {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '>>>',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '<' && ch2 === '<' && ch3 === '=') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '<<=',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '>' && ch2 === '>' && ch3 === '=') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '>>=',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '.' && ch2 === '.' && ch3 === '.') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '...',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        // Other 2-character punctuators: ++ -- << >> && ||\n\n        // Don't match these tokens if we're in a type, since they never can\n        // occur and can mess up types like Map<string, Array<string>>\n        if (ch1 === ch2 && ('+-<>&|'.indexOf(ch1) >= 0) && !state.inType) {\n            index += 2;\n            return {\n                type: Token.Punctuator,\n                value: ch1 + ch2,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '=' && ch2 === '>') {\n            index += 2;\n            return {\n                type: Token.Punctuator,\n                value: '=>',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n            ++index;\n            return {\n                type: Token.Punctuator,\n                value: ch1,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '.') {\n            ++index;\n            return {\n                type: Token.Punctuator,\n                value: ch1,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n\n    // 7.8.3 Numeric Literals\n\n    function scanHexLiteral(start) {\n        var number = '';\n\n        while (index < length) {\n            if (!isHexDigit(source[index])) {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (number.length === 0) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index))) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt('0x' + number, 16),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    function scanBinaryLiteral(start) {\n        var ch, number;\n\n        number = '';\n\n        while (index < length) {\n            ch = source[index];\n            if (ch !== '0' && ch !== '1') {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (number.length === 0) {\n            // only 0b or 0B\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        if (index < length) {\n            ch = source.charCodeAt(index);\n            /* istanbul ignore else */\n            if (isIdentifierStart(ch) || isDecimalDigit(ch)) {\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt(number, 2),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    function scanOctalLiteral(prefix, start) {\n        var number, octal;\n\n        if (isOctalDigit(prefix)) {\n            octal = true;\n            number = '0' + source[index++];\n        } else {\n            octal = false;\n            ++index;\n            number = '';\n        }\n\n        while (index < length) {\n            if (!isOctalDigit(source[index])) {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (!octal && number.length === 0) {\n            // only 0o or 0O\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt(number, 8),\n            octal: octal,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    function scanNumericLiteral() {\n        var number, start, ch;\n\n        ch = source[index];\n        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),\n            'Numeric literal must start with a decimal digit or a decimal point');\n\n        start = index;\n        number = '';\n        if (ch !== '.') {\n            number = source[index++];\n            ch = source[index];\n\n            // Hex number starts with '0x'.\n            // Octal number starts with '0'.\n            // Octal number in ES6 starts with '0o'.\n            // Binary number in ES6 starts with '0b'.\n            if (number === '0') {\n                if (ch === 'x' || ch === 'X') {\n                    ++index;\n                    return scanHexLiteral(start);\n                }\n                if (ch === 'b' || ch === 'B') {\n                    ++index;\n                    return scanBinaryLiteral(start);\n                }\n                if (ch === 'o' || ch === 'O' || isOctalDigit(ch)) {\n                    return scanOctalLiteral(ch, start);\n                }\n                // decimal number starts with '0' such as '09' is illegal.\n                if (ch && isDecimalDigit(ch.charCodeAt(0))) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n            }\n\n            while (isDecimalDigit(source.charCodeAt(index))) {\n                number += source[index++];\n            }\n            ch = source[index];\n        }\n\n        if (ch === '.') {\n            number += source[index++];\n            while (isDecimalDigit(source.charCodeAt(index))) {\n                number += source[index++];\n            }\n            ch = source[index];\n        }\n\n        if (ch === 'e' || ch === 'E') {\n            number += source[index++];\n\n            ch = source[index];\n            if (ch === '+' || ch === '-') {\n                number += source[index++];\n            }\n            if (isDecimalDigit(source.charCodeAt(index))) {\n                while (isDecimalDigit(source.charCodeAt(index))) {\n                    number += source[index++];\n                }\n            } else {\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index))) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseFloat(number),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    // 7.8.4 String Literals\n\n    function scanStringLiteral() {\n        var str = '', quote, start, ch, code, unescaped, restore, octal = false;\n\n        quote = source[index];\n        assert((quote === '\\'' || quote === '\"'),\n            'String literal must starts with a quote');\n\n        start = index;\n        ++index;\n\n        while (index < length) {\n            ch = source[index++];\n\n            if (ch === quote) {\n                quote = '';\n                break;\n            } else if (ch === '\\\\') {\n                ch = source[index++];\n                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n                    switch (ch) {\n                    case 'n':\n                        str += '\\n';\n                        break;\n                    case 'r':\n                        str += '\\r';\n                        break;\n                    case 't':\n                        str += '\\t';\n                        break;\n                    case 'u':\n                    case 'x':\n                        if (source[index] === '{') {\n                            ++index;\n                            str += scanUnicodeCodePointEscape();\n                        } else {\n                            restore = index;\n                            unescaped = scanHexEscape(ch);\n                            if (unescaped) {\n                                str += unescaped;\n                            } else {\n                                index = restore;\n                                str += ch;\n                            }\n                        }\n                        break;\n                    case 'b':\n                        str += '\\b';\n                        break;\n                    case 'f':\n                        str += '\\f';\n                        break;\n                    case 'v':\n                        str += '\\x0B';\n                        break;\n\n                    default:\n                        if (isOctalDigit(ch)) {\n                            code = '01234567'.indexOf(ch);\n\n                            // \\0 is not octal escape sequence\n                            if (code !== 0) {\n                                octal = true;\n                            }\n\n                            /* istanbul ignore else */\n                            if (index < length && isOctalDigit(source[index])) {\n                                octal = true;\n                                code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                                // 3 digits are only allowed when string starts\n                                // with 0, 1, 2, 3\n                                if ('0123'.indexOf(ch) >= 0 &&\n                                        index < length &&\n                                        isOctalDigit(source[index])) {\n                                    code = code * 8 + '01234567'.indexOf(source[index++]);\n                                }\n                            }\n                            str += String.fromCharCode(code);\n                        } else {\n                            str += ch;\n                        }\n                        break;\n                    }\n                } else {\n                    ++lineNumber;\n                    if (ch === '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                    lineStart = index;\n                }\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                break;\n            } else {\n                str += ch;\n            }\n        }\n\n        if (quote !== '') {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.StringLiteral,\n            value: str,\n            octal: octal,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    function scanTemplate() {\n        var cooked = '', ch, start, terminated, head, tail, restore, unescaped, code, octal;\n\n        terminated = false;\n        tail = false;\n        start = index;\n        head = (source[index] === '`');\n\n        ++index;\n\n        while (index < length) {\n            ch = source[index++];\n            if (ch === '`') {\n                tail = true;\n                terminated = true;\n                break;\n            } else if (ch === '$') {\n                if (source[index] === '{') {\n                    ++index;\n                    terminated = true;\n                    break;\n                }\n                cooked += ch;\n            } else if (ch === '\\\\') {\n                ch = source[index++];\n                if (!isLineTerminator(ch.charCodeAt(0))) {\n                    switch (ch) {\n                    case 'n':\n                        cooked += '\\n';\n                        break;\n                    case 'r':\n                        cooked += '\\r';\n                        break;\n                    case 't':\n                        cooked += '\\t';\n                        break;\n                    case 'u':\n                    case 'x':\n                        if (source[index] === '{') {\n                            ++index;\n                            cooked += scanUnicodeCodePointEscape();\n                        } else {\n                            restore = index;\n                            unescaped = scanHexEscape(ch);\n                            if (unescaped) {\n                                cooked += unescaped;\n                            } else {\n                                index = restore;\n                                cooked += ch;\n                            }\n                        }\n                        break;\n                    case 'b':\n                        cooked += '\\b';\n                        break;\n                    case 'f':\n                        cooked += '\\f';\n                        break;\n                    case 'v':\n                        cooked += '\\v';\n                        break;\n\n                    default:\n                        if (isOctalDigit(ch)) {\n                            code = '01234567'.indexOf(ch);\n\n                            // \\0 is not octal escape sequence\n                            if (code !== 0) {\n                                octal = true;\n                            }\n\n                            /* istanbul ignore else */\n                            if (index < length && isOctalDigit(source[index])) {\n                                octal = true;\n                                code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                                // 3 digits are only allowed when string starts\n                                // with 0, 1, 2, 3\n                                if ('0123'.indexOf(ch) >= 0 &&\n                                        index < length &&\n                                        isOctalDigit(source[index])) {\n                                    code = code * 8 + '01234567'.indexOf(source[index++]);\n                                }\n                            }\n                            cooked += String.fromCharCode(code);\n                        } else {\n                            cooked += ch;\n                        }\n                        break;\n                    }\n                } else {\n                    ++lineNumber;\n                    if (ch === '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                    lineStart = index;\n                }\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                ++lineNumber;\n                if (ch === '\\r' && source[index] === '\\n') {\n                    ++index;\n                }\n                lineStart = index;\n                cooked += '\\n';\n            } else {\n                cooked += ch;\n            }\n        }\n\n        if (!terminated) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        if (index > state.curlyLastIndex) {\n            state.curlyLastIndex = index;\n            if (!tail) {\n                state.curlyStack.push('template');\n            }\n\n            if (!head) {\n                state.curlyStack.pop();\n            }\n        }\n\n        return {\n            type: Token.Template,\n            value: {\n                cooked: cooked,\n                raw: source.slice(start + 1, index - ((tail) ? 1 : 2))\n            },\n            head: head,\n            tail: tail,\n            octal: octal,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    function testRegExp(pattern, flags) {\n        var tmp = pattern,\n            value;\n\n        if (flags.indexOf('u') >= 0) {\n            // Replace each astral symbol and every Unicode code point\n            // escape sequence with a single ASCII symbol to avoid throwing on\n            // regular expressions that are only valid in combination with the\n            // `/u` flag.\n            // Note: replacing with the ASCII symbol `x` might cause false\n            // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n            // perfectly valid pattern that is equivalent to `[a-b]`, but it\n            // would be replaced by `[x-b]` which throws an error.\n            tmp = tmp\n                .replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function ($0, $1) {\n                    if (parseInt($1, 16) <= 0x10FFFF) {\n                        return 'x';\n                    }\n                    throwError({}, Messages.InvalidRegExp);\n                })\n                .replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, 'x');\n        }\n\n        // First, detect invalid regular expressions.\n        try {\n            value = new RegExp(tmp);\n        } catch (e) {\n            throwError({}, Messages.InvalidRegExp);\n        }\n\n        // Return a regular expression object for this pattern-flag pair, or\n        // `null` in case the current environment doesn't support the flags it\n        // uses.\n        try {\n            return new RegExp(pattern, flags);\n        } catch (exception) {\n            return null;\n        }\n    }\n\n    function scanRegExpBody() {\n        var ch, str, classMarker, terminated, body;\n\n        ch = source[index];\n        assert(ch === '/', 'Regular expression literal must start with a slash');\n        str = source[index++];\n\n        classMarker = false;\n        terminated = false;\n        while (index < length) {\n            ch = source[index++];\n            str += ch;\n            if (ch === '\\\\') {\n                ch = source[index++];\n                // ECMA-262 7.8.5\n                if (isLineTerminator(ch.charCodeAt(0))) {\n                    throwError({}, Messages.UnterminatedRegExp);\n                }\n                str += ch;\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                throwError({}, Messages.UnterminatedRegExp);\n            } else if (classMarker) {\n                if (ch === ']') {\n                    classMarker = false;\n                }\n            } else {\n                if (ch === '/') {\n                    terminated = true;\n                    break;\n                } else if (ch === '[') {\n                    classMarker = true;\n                }\n            }\n        }\n\n        if (!terminated) {\n            throwError({}, Messages.UnterminatedRegExp);\n        }\n\n        // Exclude leading and trailing slash.\n        body = str.substr(1, str.length - 2);\n        return {\n            value: body,\n            literal: str\n        };\n    }\n\n    function scanRegExpFlags() {\n        var ch, str, flags, restore;\n\n        str = '';\n        flags = '';\n        while (index < length) {\n            ch = source[index];\n            if (!isIdentifierPart(ch.charCodeAt(0))) {\n                break;\n            }\n\n            ++index;\n            if (ch === '\\\\' && index < length) {\n                ch = source[index];\n                if (ch === 'u') {\n                    ++index;\n                    restore = index;\n                    ch = scanHexEscape('u');\n                    if (ch) {\n                        flags += ch;\n                        for (str += '\\\\u'; restore < index; ++restore) {\n                            str += source[restore];\n                        }\n                    } else {\n                        index = restore;\n                        flags += 'u';\n                        str += '\\\\u';\n                    }\n                    throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n                } else {\n                    str += '\\\\';\n                    throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n            } else {\n                flags += ch;\n                str += ch;\n            }\n        }\n\n        return {\n            value: flags,\n            literal: str\n        };\n    }\n\n    function scanRegExp() {\n        var start, body, flags, value;\n\n        lookahead = null;\n        skipComment();\n        start = index;\n\n        body = scanRegExpBody();\n        flags = scanRegExpFlags();\n        value = testRegExp(body.value, flags.value);\n\n        if (extra.tokenize) {\n            return {\n                type: Token.RegularExpression,\n                value: value,\n                regex: {\n                    pattern: body.value,\n                    flags: flags.value\n                },\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        return {\n            literal: body.literal + flags.literal,\n            value: value,\n            regex: {\n                pattern: body.value,\n                flags: flags.value\n            },\n            range: [start, index]\n        };\n    }\n\n    function isIdentifierName(token) {\n        return token.type === Token.Identifier ||\n            token.type === Token.Keyword ||\n            token.type === Token.BooleanLiteral ||\n            token.type === Token.NullLiteral;\n    }\n\n    function advanceSlash() {\n        var prevToken,\n            checkToken;\n        // Using the following algorithm:\n        // https://github.com/mozilla/sweet.js/wiki/design\n        prevToken = extra.tokens[extra.tokens.length - 1];\n        if (!prevToken) {\n            // Nothing before that: it cannot be a division.\n            return scanRegExp();\n        }\n        if (prevToken.type === 'Punctuator') {\n            if (prevToken.value === ')') {\n                checkToken = extra.tokens[extra.openParenToken - 1];\n                if (checkToken &&\n                        checkToken.type === 'Keyword' &&\n                        (checkToken.value === 'if' ||\n                         checkToken.value === 'while' ||\n                         checkToken.value === 'for' ||\n                         checkToken.value === 'with')) {\n                    return scanRegExp();\n                }\n                return scanPunctuator();\n            }\n            if (prevToken.value === '}') {\n                // Dividing a function by anything makes little sense,\n                // but we have to check for that.\n                if (extra.tokens[extra.openCurlyToken - 3] &&\n                        extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {\n                    // Anonymous function.\n                    checkToken = extra.tokens[extra.openCurlyToken - 4];\n                    if (!checkToken) {\n                        return scanPunctuator();\n                    }\n                } else if (extra.tokens[extra.openCurlyToken - 4] &&\n                        extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {\n                    // Named function.\n                    checkToken = extra.tokens[extra.openCurlyToken - 5];\n                    if (!checkToken) {\n                        return scanRegExp();\n                    }\n                } else {\n                    return scanPunctuator();\n                }\n                // checkToken determines whether the function is\n                // a declaration or an expression.\n                if (FnExprTokens.indexOf(checkToken.value) >= 0) {\n                    // It is an expression.\n                    return scanPunctuator();\n                }\n                // It is a declaration.\n                return scanRegExp();\n            }\n            return scanRegExp();\n        }\n        if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {\n            return scanRegExp();\n        }\n        return scanPunctuator();\n    }\n\n    function advance() {\n        var ch;\n\n        if (!state.inJSXChild) {\n            skipComment();\n        }\n\n        if (index >= length) {\n            return {\n                type: Token.EOF,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [index, index]\n            };\n        }\n\n        if (state.inJSXChild) {\n            return advanceJSXChild();\n        }\n\n        ch = source.charCodeAt(index);\n\n        // Very common: ( and ) and ;\n        if (ch === 40 || ch === 41 || ch === 58) {\n            return scanPunctuator();\n        }\n\n        // String literal starts with single quote (#39) or double quote (#34).\n        if (ch === 39 || ch === 34) {\n            if (state.inJSXTag) {\n                return scanJSXStringLiteral();\n            }\n            return scanStringLiteral();\n        }\n\n        if (state.inJSXTag && isJSXIdentifierStart(ch)) {\n            return scanJSXIdentifier();\n        }\n\n        // Template literals start with backtick (#96) for template head\n        // or close curly (#125) for template middle or template tail.\n        if (ch === 96 || (ch === 125 && state.curlyStack[state.curlyStack.length - 1] === 'template')) {\n            return scanTemplate();\n        }\n        if (isIdentifierStart(ch)) {\n            return scanIdentifier();\n        }\n\n        // Dot (.) char #46 can also start a floating-point number, hence the need\n        // to check the next character.\n        if (ch === 46) {\n            if (isDecimalDigit(source.charCodeAt(index + 1))) {\n                return scanNumericLiteral();\n            }\n            return scanPunctuator();\n        }\n\n        if (isDecimalDigit(ch)) {\n            return scanNumericLiteral();\n        }\n\n        // Slash (/) char #47 can also start a regex.\n        if (extra.tokenize && ch === 47) {\n            return advanceSlash();\n        }\n\n        return scanPunctuator();\n    }\n\n    function lex() {\n        var token;\n\n        token = lookahead;\n        index = token.range[1];\n        lineNumber = token.lineNumber;\n        lineStart = token.lineStart;\n\n        lookahead = advance();\n\n        index = token.range[1];\n        lineNumber = token.lineNumber;\n        lineStart = token.lineStart;\n\n        return token;\n    }\n\n    function peek() {\n        var pos, line, start;\n\n        pos = index;\n        line = lineNumber;\n        start = lineStart;\n        lookahead = advance();\n        index = pos;\n        lineNumber = line;\n        lineStart = start;\n    }\n\n    function lookahead2() {\n        var adv, pos, line, start, result;\n\n        // If we are collecting the tokens, don't grab the next one yet.\n        /* istanbul ignore next */\n        adv = (typeof extra.advance === 'function') ? extra.advance : advance;\n\n        pos = index;\n        line = lineNumber;\n        start = lineStart;\n\n        // Scan for the next immediate token.\n        /* istanbul ignore if */\n        if (lookahead === null) {\n            lookahead = adv();\n        }\n        index = lookahead.range[1];\n        lineNumber = lookahead.lineNumber;\n        lineStart = lookahead.lineStart;\n\n        // Grab the token right after.\n        result = adv();\n        index = pos;\n        lineNumber = line;\n        lineStart = start;\n\n        return result;\n    }\n\n    function rewind(token) {\n        index = token.range[0];\n        lineNumber = token.lineNumber;\n        lineStart = token.lineStart;\n        lookahead = token;\n    }\n\n    function markerCreate() {\n        if (!extra.loc && !extra.range) {\n            return undefined;\n        }\n        skipComment();\n        return {offset: index, line: lineNumber, col: index - lineStart};\n    }\n\n    function markerCreatePreserveWhitespace() {\n        if (!extra.loc && !extra.range) {\n            return undefined;\n        }\n        return {offset: index, line: lineNumber, col: index - lineStart};\n    }\n\n    function processComment(node) {\n        var lastChild,\n            trailingComments,\n            bottomRight = extra.bottomRightStack,\n            last = bottomRight[bottomRight.length - 1];\n\n        if (node.type === Syntax.Program) {\n            /* istanbul ignore else */\n            if (node.body.length > 0) {\n                return;\n            }\n        }\n\n        if (extra.trailingComments.length > 0) {\n            if (extra.trailingComments[0].range[0] >= node.range[1]) {\n                trailingComments = extra.trailingComments;\n                extra.trailingComments = [];\n            } else {\n                extra.trailingComments.length = 0;\n            }\n        } else {\n            if (last && last.trailingComments && last.trailingComments[0].range[0] >= node.range[1]) {\n                trailingComments = last.trailingComments;\n                delete last.trailingComments;\n            }\n        }\n\n        // Eating the stack.\n        if (last) {\n            while (last && last.range[0] >= node.range[0]) {\n                lastChild = last;\n                last = bottomRight.pop();\n            }\n        }\n\n        if (lastChild) {\n            if (lastChild.leadingComments && lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= node.range[0]) {\n                node.leadingComments = lastChild.leadingComments;\n                delete lastChild.leadingComments;\n            }\n        } else if (extra.leadingComments.length > 0 && extra.leadingComments[extra.leadingComments.length - 1].range[1] <= node.range[0]) {\n            node.leadingComments = extra.leadingComments;\n            extra.leadingComments = [];\n        }\n\n        if (trailingComments) {\n            node.trailingComments = trailingComments;\n        }\n\n        bottomRight.push(node);\n    }\n\n    function markerApply(marker, node) {\n        if (extra.range) {\n            node.range = [marker.offset, index];\n        }\n        if (extra.loc) {\n            node.loc = {\n                start: {\n                    line: marker.line,\n                    column: marker.col\n                },\n                end: {\n                    line: lineNumber,\n                    column: index - lineStart\n                }\n            };\n            node = delegate.postProcess(node);\n        }\n        if (extra.attachComment) {\n            processComment(node);\n        }\n        return node;\n    }\n\n    SyntaxTreeDelegate = {\n\n        name: 'SyntaxTree',\n\n        postProcess: function (node) {\n            return node;\n        },\n\n        createArrayExpression: function (elements) {\n            return {\n                type: Syntax.ArrayExpression,\n                elements: elements\n            };\n        },\n\n        createAssignmentExpression: function (operator, left, right) {\n            return {\n                type: Syntax.AssignmentExpression,\n                operator: operator,\n                left: left,\n                right: right\n            };\n        },\n\n        createBinaryExpression: function (operator, left, right) {\n            var type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression :\n                        Syntax.BinaryExpression;\n            return {\n                type: type,\n                operator: operator,\n                left: left,\n                right: right\n            };\n        },\n\n        createBlockStatement: function (body) {\n            return {\n                type: Syntax.BlockStatement,\n                body: body\n            };\n        },\n\n        createBreakStatement: function (label) {\n            return {\n                type: Syntax.BreakStatement,\n                label: label\n            };\n        },\n\n        createCallExpression: function (callee, args) {\n            return {\n                type: Syntax.CallExpression,\n                callee: callee,\n                'arguments': args\n            };\n        },\n\n        createCatchClause: function (param, body) {\n            return {\n                type: Syntax.CatchClause,\n                param: param,\n                body: body\n            };\n        },\n\n        createConditionalExpression: function (test, consequent, alternate) {\n            return {\n                type: Syntax.ConditionalExpression,\n                test: test,\n                consequent: consequent,\n                alternate: alternate\n            };\n        },\n\n        createContinueStatement: function (label) {\n            return {\n                type: Syntax.ContinueStatement,\n                label: label\n            };\n        },\n\n        createDebuggerStatement: function () {\n            return {\n                type: Syntax.DebuggerStatement\n            };\n        },\n\n        createDoWhileStatement: function (body, test) {\n            return {\n                type: Syntax.DoWhileStatement,\n                body: body,\n                test: test\n            };\n        },\n\n        createEmptyStatement: function () {\n            return {\n                type: Syntax.EmptyStatement\n            };\n        },\n\n        createExpressionStatement: function (expression) {\n            return {\n                type: Syntax.ExpressionStatement,\n                expression: expression\n            };\n        },\n\n        createForStatement: function (init, test, update, body) {\n            return {\n                type: Syntax.ForStatement,\n                init: init,\n                test: test,\n                update: update,\n                body: body\n            };\n        },\n\n        createForInStatement: function (left, right, body) {\n            return {\n                type: Syntax.ForInStatement,\n                left: left,\n                right: right,\n                body: body,\n                each: false\n            };\n        },\n\n        createForOfStatement: function (left, right, body) {\n            return {\n                type: Syntax.ForOfStatement,\n                left: left,\n                right: right,\n                body: body\n            };\n        },\n\n        createFunctionDeclaration: function (id, params, defaults, body, rest, generator, expression,\n                                             isAsync, returnType, typeParameters) {\n            var funDecl = {\n                type: Syntax.FunctionDeclaration,\n                id: id,\n                params: params,\n                defaults: defaults,\n                body: body,\n                rest: rest,\n                generator: generator,\n                expression: expression,\n                returnType: returnType,\n                typeParameters: typeParameters\n            };\n\n            if (isAsync) {\n                funDecl.async = true;\n            }\n\n            return funDecl;\n        },\n\n        createFunctionExpression: function (id, params, defaults, body, rest, generator, expression,\n                                            isAsync, returnType, typeParameters) {\n            var funExpr = {\n                type: Syntax.FunctionExpression,\n                id: id,\n                params: params,\n                defaults: defaults,\n                body: body,\n                rest: rest,\n                generator: generator,\n                expression: expression,\n                returnType: returnType,\n                typeParameters: typeParameters\n            };\n\n            if (isAsync) {\n                funExpr.async = true;\n            }\n\n            return funExpr;\n        },\n\n        createIdentifier: function (name) {\n            return {\n                type: Syntax.Identifier,\n                name: name,\n                // Only here to initialize the shape of the object to ensure\n                // that the 'typeAnnotation' key is ordered before others that\n                // are added later (like 'loc' and 'range'). This just helps\n                // keep the shape of Identifier nodes consistent with everything\n                // else.\n                typeAnnotation: undefined,\n                optional: undefined\n            };\n        },\n\n        createTypeAnnotation: function (typeAnnotation) {\n            return {\n                type: Syntax.TypeAnnotation,\n                typeAnnotation: typeAnnotation\n            };\n        },\n\n        createTypeCast: function (expression, typeAnnotation) {\n            return {\n                type: Syntax.TypeCastExpression,\n                expression: expression,\n                typeAnnotation: typeAnnotation\n            };\n        },\n\n        createFunctionTypeAnnotation: function (params, returnType, rest, typeParameters) {\n            return {\n                type: Syntax.FunctionTypeAnnotation,\n                params: params,\n                returnType: returnType,\n                rest: rest,\n                typeParameters: typeParameters\n            };\n        },\n\n        createFunctionTypeParam: function (name, typeAnnotation, optional) {\n            return {\n                type: Syntax.FunctionTypeParam,\n                name: name,\n                typeAnnotation: typeAnnotation,\n                optional: optional\n            };\n        },\n\n        createNullableTypeAnnotation: function (typeAnnotation) {\n            return {\n                type: Syntax.NullableTypeAnnotation,\n                typeAnnotation: typeAnnotation\n            };\n        },\n\n        createArrayTypeAnnotation: function (elementType) {\n            return {\n                type: Syntax.ArrayTypeAnnotation,\n                elementType: elementType\n            };\n        },\n\n        createGenericTypeAnnotation: function (id, typeParameters) {\n            return {\n                type: Syntax.GenericTypeAnnotation,\n                id: id,\n                typeParameters: typeParameters\n            };\n        },\n\n        createQualifiedTypeIdentifier: function (qualification, id) {\n            return {\n                type: Syntax.QualifiedTypeIdentifier,\n                qualification: qualification,\n                id: id\n            };\n        },\n\n        createTypeParameterDeclaration: function (params) {\n            return {\n                type: Syntax.TypeParameterDeclaration,\n                params: params\n            };\n        },\n\n        createTypeParameterInstantiation: function (params) {\n            return {\n                type: Syntax.TypeParameterInstantiation,\n                params: params\n            };\n        },\n\n        createAnyTypeAnnotation: function () {\n            return {\n                type: Syntax.AnyTypeAnnotation\n            };\n        },\n\n        createBooleanTypeAnnotation: function () {\n            return {\n                type: Syntax.BooleanTypeAnnotation\n            };\n        },\n\n        createNumberTypeAnnotation: function () {\n            return {\n                type: Syntax.NumberTypeAnnotation\n            };\n        },\n\n        createStringTypeAnnotation: function () {\n            return {\n                type: Syntax.StringTypeAnnotation\n            };\n        },\n\n        createStringLiteralTypeAnnotation: function (token) {\n            return {\n                type: Syntax.StringLiteralTypeAnnotation,\n                value: token.value,\n                raw: source.slice(token.range[0], token.range[1])\n            };\n        },\n\n        createVoidTypeAnnotation: function () {\n            return {\n                type: Syntax.VoidTypeAnnotation\n            };\n        },\n\n        createTypeofTypeAnnotation: function (argument) {\n            return {\n                type: Syntax.TypeofTypeAnnotation,\n                argument: argument\n            };\n        },\n\n        createTupleTypeAnnotation: function (types) {\n            return {\n                type: Syntax.TupleTypeAnnotation,\n                types: types\n            };\n        },\n\n        createObjectTypeAnnotation: function (properties, indexers, callProperties) {\n            return {\n                type: Syntax.ObjectTypeAnnotation,\n                properties: properties,\n                indexers: indexers,\n                callProperties: callProperties\n            };\n        },\n\n        createObjectTypeIndexer: function (id, key, value, isStatic) {\n            return {\n                type: Syntax.ObjectTypeIndexer,\n                id: id,\n                key: key,\n                value: value,\n                static: isStatic\n            };\n        },\n\n        createObjectTypeCallProperty: function (value, isStatic) {\n            return {\n                type: Syntax.ObjectTypeCallProperty,\n                value: value,\n                static: isStatic\n            };\n        },\n\n        createObjectTypeProperty: function (key, value, optional, isStatic) {\n            return {\n                type: Syntax.ObjectTypeProperty,\n                key: key,\n                value: value,\n                optional: optional,\n                static: isStatic\n            };\n        },\n\n        createUnionTypeAnnotation: function (types) {\n            return {\n                type: Syntax.UnionTypeAnnotation,\n                types: types\n            };\n        },\n\n        createIntersectionTypeAnnotation: function (types) {\n            return {\n                type: Syntax.IntersectionTypeAnnotation,\n                types: types\n            };\n        },\n\n        createTypeAlias: function (id, typeParameters, right) {\n            return {\n                type: Syntax.TypeAlias,\n                id: id,\n                typeParameters: typeParameters,\n                right: right\n            };\n        },\n\n        createInterface: function (id, typeParameters, body, extended) {\n            return {\n                type: Syntax.InterfaceDeclaration,\n                id: id,\n                typeParameters: typeParameters,\n                body: body,\n                extends: extended\n            };\n        },\n\n        createInterfaceExtends: function (id, typeParameters) {\n            return {\n                type: Syntax.InterfaceExtends,\n                id: id,\n                typeParameters: typeParameters\n            };\n        },\n\n        createDeclareFunction: function (id) {\n            return {\n                type: Syntax.DeclareFunction,\n                id: id\n            };\n        },\n\n        createDeclareVariable: function (id) {\n            return {\n                type: Syntax.DeclareVariable,\n                id: id\n            };\n        },\n\n        createDeclareModule: function (id, body) {\n            return {\n                type: Syntax.DeclareModule,\n                id: id,\n                body: body\n            };\n        },\n\n        createJSXAttribute: function (name, value) {\n            return {\n                type: Syntax.JSXAttribute,\n                name: name,\n                value: value || null\n            };\n        },\n\n        createJSXSpreadAttribute: function (argument) {\n            return {\n                type: Syntax.JSXSpreadAttribute,\n                argument: argument\n            };\n        },\n\n        createJSXIdentifier: function (name) {\n            return {\n                type: Syntax.JSXIdentifier,\n                name: name\n            };\n        },\n\n        createJSXNamespacedName: function (namespace, name) {\n            return {\n                type: Syntax.JSXNamespacedName,\n                namespace: namespace,\n                name: name\n            };\n        },\n\n        createJSXMemberExpression: function (object, property) {\n            return {\n                type: Syntax.JSXMemberExpression,\n                object: object,\n                property: property\n            };\n        },\n\n        createJSXElement: function (openingElement, closingElement, children) {\n            return {\n                type: Syntax.JSXElement,\n                openingElement: openingElement,\n                closingElement: closingElement,\n                children: children\n            };\n        },\n\n        createJSXEmptyExpression: function () {\n            return {\n                type: Syntax.JSXEmptyExpression\n            };\n        },\n\n        createJSXExpressionContainer: function (expression) {\n            return {\n                type: Syntax.JSXExpressionContainer,\n                expression: expression\n            };\n        },\n\n        createJSXOpeningElement: function (name, attributes, selfClosing) {\n            return {\n                type: Syntax.JSXOpeningElement,\n                name: name,\n                selfClosing: selfClosing,\n                attributes: attributes\n            };\n        },\n\n        createJSXClosingElement: function (name) {\n            return {\n                type: Syntax.JSXClosingElement,\n                name: name\n            };\n        },\n\n        createIfStatement: function (test, consequent, alternate) {\n            return {\n                type: Syntax.IfStatement,\n                test: test,\n                consequent: consequent,\n                alternate: alternate\n            };\n        },\n\n        createLabeledStatement: function (label, body) {\n            return {\n                type: Syntax.LabeledStatement,\n                label: label,\n                body: body\n            };\n        },\n\n        createLiteral: function (token) {\n            var object = {\n                type: Syntax.Literal,\n                value: token.value,\n                raw: source.slice(token.range[0], token.range[1])\n            };\n            if (token.regex) {\n                object.regex = token.regex;\n            }\n            return object;\n        },\n\n        createMemberExpression: function (accessor, object, property) {\n            return {\n                type: Syntax.MemberExpression,\n                computed: accessor === '[',\n                object: object,\n                property: property\n            };\n        },\n\n        createNewExpression: function (callee, args) {\n            return {\n                type: Syntax.NewExpression,\n                callee: callee,\n                'arguments': args\n            };\n        },\n\n        createObjectExpression: function (properties) {\n            return {\n                type: Syntax.ObjectExpression,\n                properties: properties\n            };\n        },\n\n        createPostfixExpression: function (operator, argument) {\n            return {\n                type: Syntax.UpdateExpression,\n                operator: operator,\n                argument: argument,\n                prefix: false\n            };\n        },\n\n        createProgram: function (body) {\n            return {\n                type: Syntax.Program,\n                body: body\n            };\n        },\n\n        createProperty: function (kind, key, value, method, shorthand, computed) {\n            return {\n                type: Syntax.Property,\n                key: key,\n                value: value,\n                kind: kind,\n                method: method,\n                shorthand: shorthand,\n                computed: computed\n            };\n        },\n\n        createReturnStatement: function (argument) {\n            return {\n                type: Syntax.ReturnStatement,\n                argument: argument\n            };\n        },\n\n        createSequenceExpression: function (expressions) {\n            return {\n                type: Syntax.SequenceExpression,\n                expressions: expressions\n            };\n        },\n\n        createSwitchCase: function (test, consequent) {\n            return {\n                type: Syntax.SwitchCase,\n                test: test,\n                consequent: consequent\n            };\n        },\n\n        createSwitchStatement: function (discriminant, cases) {\n            return {\n                type: Syntax.SwitchStatement,\n                discriminant: discriminant,\n                cases: cases\n            };\n        },\n\n        createThisExpression: function () {\n            return {\n                type: Syntax.ThisExpression\n            };\n        },\n\n        createThrowStatement: function (argument) {\n            return {\n                type: Syntax.ThrowStatement,\n                argument: argument\n            };\n        },\n\n        createTryStatement: function (block, guardedHandlers, handlers, finalizer) {\n            return {\n                type: Syntax.TryStatement,\n                block: block,\n                guardedHandlers: guardedHandlers,\n                handlers: handlers,\n                finalizer: finalizer\n            };\n        },\n\n        createUnaryExpression: function (operator, argument) {\n            if (operator === '++' || operator === '--') {\n                return {\n                    type: Syntax.UpdateExpression,\n                    operator: operator,\n                    argument: argument,\n                    prefix: true\n                };\n            }\n            return {\n                type: Syntax.UnaryExpression,\n                operator: operator,\n                argument: argument,\n                prefix: true\n            };\n        },\n\n        createVariableDeclaration: function (declarations, kind) {\n            return {\n                type: Syntax.VariableDeclaration,\n                declarations: declarations,\n                kind: kind\n            };\n        },\n\n        createVariableDeclarator: function (id, init) {\n            return {\n                type: Syntax.VariableDeclarator,\n                id: id,\n                init: init\n            };\n        },\n\n        createWhileStatement: function (test, body) {\n            return {\n                type: Syntax.WhileStatement,\n                test: test,\n                body: body\n            };\n        },\n\n        createWithStatement: function (object, body) {\n            return {\n                type: Syntax.WithStatement,\n                object: object,\n                body: body\n            };\n        },\n\n        createTemplateElement: function (value, tail) {\n            return {\n                type: Syntax.TemplateElement,\n                value: value,\n                tail: tail\n            };\n        },\n\n        createTemplateLiteral: function (quasis, expressions) {\n            return {\n                type: Syntax.TemplateLiteral,\n                quasis: quasis,\n                expressions: expressions\n            };\n        },\n\n        createSpreadElement: function (argument) {\n            return {\n                type: Syntax.SpreadElement,\n                argument: argument\n            };\n        },\n\n        createSpreadProperty: function (argument) {\n            return {\n                type: Syntax.SpreadProperty,\n                argument: argument\n            };\n        },\n\n        createTaggedTemplateExpression: function (tag, quasi) {\n            return {\n                type: Syntax.TaggedTemplateExpression,\n                tag: tag,\n                quasi: quasi\n            };\n        },\n\n        createArrowFunctionExpression: function (params, defaults, body, rest, expression, isAsync) {\n            var arrowExpr = {\n                type: Syntax.ArrowFunctionExpression,\n                id: null,\n                params: params,\n                defaults: defaults,\n                body: body,\n                rest: rest,\n                generator: false,\n                expression: expression\n            };\n\n            if (isAsync) {\n                arrowExpr.async = true;\n            }\n\n            return arrowExpr;\n        },\n\n        createMethodDefinition: function (propertyType, kind, key, value, computed) {\n            return {\n                type: Syntax.MethodDefinition,\n                key: key,\n                value: value,\n                kind: kind,\n                'static': propertyType === ClassPropertyType.static,\n                computed: computed\n            };\n        },\n\n        createClassProperty: function (key, typeAnnotation, computed, isStatic) {\n            return {\n                type: Syntax.ClassProperty,\n                key: key,\n                typeAnnotation: typeAnnotation,\n                computed: computed,\n                static: isStatic\n            };\n        },\n\n        createClassBody: function (body) {\n            return {\n                type: Syntax.ClassBody,\n                body: body\n            };\n        },\n\n        createClassImplements: function (id, typeParameters) {\n            return {\n                type: Syntax.ClassImplements,\n                id: id,\n                typeParameters: typeParameters\n            };\n        },\n\n        createClassExpression: function (id, superClass, body, typeParameters, superTypeParameters, implemented) {\n            return {\n                type: Syntax.ClassExpression,\n                id: id,\n                superClass: superClass,\n                body: body,\n                typeParameters: typeParameters,\n                superTypeParameters: superTypeParameters,\n                implements: implemented\n            };\n        },\n\n        createClassDeclaration: function (id, superClass, body, typeParameters, superTypeParameters, implemented) {\n            return {\n                type: Syntax.ClassDeclaration,\n                id: id,\n                superClass: superClass,\n                body: body,\n                typeParameters: typeParameters,\n                superTypeParameters: superTypeParameters,\n                implements: implemented\n            };\n        },\n\n        createExportSpecifier: function (id, name) {\n            return {\n                type: Syntax.ExportSpecifier,\n                id: id,\n                name: name\n            };\n        },\n\n        createExportBatchSpecifier: function () {\n            return {\n                type: Syntax.ExportBatchSpecifier\n            };\n        },\n\n        createImportDefaultSpecifier: function (id) {\n            return {\n                type: Syntax.ImportDefaultSpecifier,\n                id: id\n            };\n        },\n\n        createImportNamespaceSpecifier: function (id) {\n            return {\n                type: Syntax.ImportNamespaceSpecifier,\n                id: id\n            };\n        },\n\n        createExportDeclaration: function (isDefault, declaration, specifiers, src, exportKind) {\n            return {\n                type: Syntax.ExportDeclaration,\n                'default': !!isDefault,\n                declaration: declaration,\n                specifiers: specifiers,\n                source: src,\n                exportKind: exportKind\n            };\n        },\n\n        createImportSpecifier: function (id, name) {\n            return {\n                type: Syntax.ImportSpecifier,\n                id: id,\n                name: name\n            };\n        },\n\n        createImportDeclaration: function (specifiers, src, importKind) {\n            return {\n                type: Syntax.ImportDeclaration,\n                specifiers: specifiers,\n                source: src,\n                importKind: importKind\n            };\n        },\n\n        createYieldExpression: function (argument, dlg) {\n            return {\n                type: Syntax.YieldExpression,\n                argument: argument,\n                delegate: dlg\n            };\n        },\n\n        createAwaitExpression: function (argument) {\n            return {\n                type: Syntax.AwaitExpression,\n                argument: argument\n            };\n        },\n\n        createComprehensionExpression: function (filter, blocks, body) {\n            return {\n                type: Syntax.ComprehensionExpression,\n                filter: filter,\n                blocks: blocks,\n                body: body\n            };\n        }\n\n    };\n\n    // Return true if there is a line terminator before the next token.\n\n    function peekLineTerminator() {\n        var pos, line, start, found;\n\n        pos = index;\n        line = lineNumber;\n        start = lineStart;\n        skipComment();\n        found = lineNumber !== line;\n        index = pos;\n        lineNumber = line;\n        lineStart = start;\n\n        return found;\n    }\n\n    // Throw an exception\n\n    function throwError(token, messageFormat) {\n        var error,\n            args = Array.prototype.slice.call(arguments, 2),\n            msg = messageFormat.replace(\n                /%(\\d)/g,\n                function (whole, idx) {\n                    assert(idx < args.length, 'Message reference must be in range');\n                    return args[idx];\n                }\n            );\n\n        if (typeof token.lineNumber === 'number') {\n            error = new Error('Line ' + token.lineNumber + ': ' + msg);\n            error.index = token.range[0];\n            error.lineNumber = token.lineNumber;\n            error.column = token.range[0] - lineStart + 1;\n        } else {\n            error = new Error('Line ' + lineNumber + ': ' + msg);\n            error.index = index;\n            error.lineNumber = lineNumber;\n            error.column = index - lineStart + 1;\n        }\n\n        error.description = msg;\n        throw error;\n    }\n\n    function throwErrorTolerant() {\n        try {\n            throwError.apply(null, arguments);\n        } catch (e) {\n            if (extra.errors) {\n                extra.errors.push(e);\n            } else {\n                throw e;\n            }\n        }\n    }\n\n\n    // Throw an exception because of the token.\n\n    function throwUnexpected(token) {\n        if (token.type === Token.EOF) {\n            throwError(token, Messages.UnexpectedEOS);\n        }\n\n        if (token.type === Token.NumericLiteral) {\n            throwError(token, Messages.UnexpectedNumber);\n        }\n\n        if (token.type === Token.StringLiteral || token.type === Token.JSXText) {\n            throwError(token, Messages.UnexpectedString);\n        }\n\n        if (token.type === Token.Identifier) {\n            throwError(token, Messages.UnexpectedIdentifier);\n        }\n\n        if (token.type === Token.Keyword) {\n            if (isFutureReservedWord(token.value)) {\n                throwError(token, Messages.UnexpectedReserved);\n            } else if (strict && isStrictModeReservedWord(token.value)) {\n                throwErrorTolerant(token, Messages.StrictReservedWord);\n                return;\n            }\n            throwError(token, Messages.UnexpectedToken, token.value);\n        }\n\n        if (token.type === Token.Template) {\n            throwError(token, Messages.UnexpectedTemplate, token.value.raw);\n        }\n\n        // BooleanLiteral, NullLiteral, or Punctuator.\n        throwError(token, Messages.UnexpectedToken, token.value);\n    }\n\n    // Expect the next token to match the specified punctuator.\n    // If not, an exception will be thrown.\n\n    function expect(value) {\n        var token = lex();\n        if (token.type !== Token.Punctuator || token.value !== value) {\n            throwUnexpected(token);\n        }\n    }\n\n    // Expect the next token to match the specified keyword.\n    // If not, an exception will be thrown.\n\n    function expectKeyword(keyword, contextual) {\n        var token = lex();\n        if (token.type !== (contextual ? Token.Identifier : Token.Keyword) ||\n                token.value !== keyword) {\n            throwUnexpected(token);\n        }\n    }\n\n    // Expect the next token to match the specified contextual keyword.\n    // If not, an exception will be thrown.\n\n    function expectContextualKeyword(keyword) {\n        return expectKeyword(keyword, true);\n    }\n\n    // Return true if the next token matches the specified punctuator.\n\n    function match(value) {\n        return lookahead.type === Token.Punctuator && lookahead.value === value;\n    }\n\n    // Return true if the next token matches the specified keyword\n\n    function matchKeyword(keyword, contextual) {\n        var expectedType = contextual ? Token.Identifier : Token.Keyword;\n        return lookahead.type === expectedType && lookahead.value === keyword;\n    }\n\n    // Return true if the next token matches the specified contextual keyword\n\n    function matchContextualKeyword(keyword) {\n        return matchKeyword(keyword, true);\n    }\n\n    // Return true if the next token is an assignment operator\n\n    function matchAssign() {\n        var op;\n\n        if (lookahead.type !== Token.Punctuator) {\n            return false;\n        }\n        op = lookahead.value;\n        return op === '=' ||\n            op === '*=' ||\n            op === '/=' ||\n            op === '%=' ||\n            op === '+=' ||\n            op === '-=' ||\n            op === '<<=' ||\n            op === '>>=' ||\n            op === '>>>=' ||\n            op === '&=' ||\n            op === '^=' ||\n            op === '|=';\n    }\n\n    // Note that 'yield' is treated as a keyword in strict mode, but a\n    // contextual keyword (identifier) in non-strict mode, so we need to\n    // use matchKeyword('yield', false) and matchKeyword('yield', true)\n    // (i.e. matchContextualKeyword) appropriately.\n    function matchYield() {\n        return state.yieldAllowed && matchKeyword('yield', !strict);\n    }\n\n    function matchAsync() {\n        var backtrackToken = lookahead, matches = false;\n\n        if (matchContextualKeyword('async')) {\n            lex(); // Make sure peekLineTerminator() starts after 'async'.\n            matches = !peekLineTerminator();\n            rewind(backtrackToken); // Revert the lex().\n        }\n\n        return matches;\n    }\n\n    function matchAwait() {\n        return state.awaitAllowed && matchContextualKeyword('await');\n    }\n\n    function consumeSemicolon() {\n        var line, oldIndex = index, oldLineNumber = lineNumber,\n            oldLineStart = lineStart, oldLookahead = lookahead;\n\n        // Catch the very common case first: immediately a semicolon (char #59).\n        if (source.charCodeAt(index) === 59) {\n            lex();\n            return;\n        }\n\n        line = lineNumber;\n        skipComment();\n        if (lineNumber !== line) {\n            index = oldIndex;\n            lineNumber = oldLineNumber;\n            lineStart = oldLineStart;\n            lookahead = oldLookahead;\n            return;\n        }\n\n        if (match(';')) {\n            lex();\n            return;\n        }\n\n        if (lookahead.type !== Token.EOF && !match('}')) {\n            throwUnexpected(lookahead);\n        }\n    }\n\n    // Return true if provided expression is LeftHandSideExpression\n\n    function isLeftHandSide(expr) {\n        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;\n    }\n\n    function isAssignableLeftHandSide(expr) {\n        return isLeftHandSide(expr) || expr.type === Syntax.ObjectPattern || expr.type === Syntax.ArrayPattern;\n    }\n\n    // 11.1.4 Array Initialiser\n\n    function parseArrayInitialiser() {\n        var elements = [], blocks = [], filter = null, tmp, possiblecomprehension = true,\n            marker = markerCreate();\n\n        expect('[');\n        while (!match(']')) {\n            if (lookahead.value === 'for' &&\n                    lookahead.type === Token.Keyword) {\n                if (!possiblecomprehension) {\n                    throwError({}, Messages.ComprehensionError);\n                }\n                matchKeyword('for');\n                tmp = parseForStatement({ignoreBody: true});\n                tmp.of = tmp.type === Syntax.ForOfStatement;\n                tmp.type = Syntax.ComprehensionBlock;\n                if (tmp.left.kind) { // can't be let or const\n                    throwError({}, Messages.ComprehensionError);\n                }\n                blocks.push(tmp);\n            } else if (lookahead.value === 'if' &&\n                           lookahead.type === Token.Keyword) {\n                if (!possiblecomprehension) {\n                    throwError({}, Messages.ComprehensionError);\n                }\n                expectKeyword('if');\n                expect('(');\n                filter = parseExpression();\n                expect(')');\n            } else if (lookahead.value === ',' &&\n                           lookahead.type === Token.Punctuator) {\n                possiblecomprehension = false; // no longer allowed.\n                lex();\n                elements.push(null);\n            } else {\n                tmp = parseSpreadOrAssignmentExpression();\n                elements.push(tmp);\n                if (tmp && tmp.type === Syntax.SpreadElement) {\n                    if (!match(']')) {\n                        throwError({}, Messages.ElementAfterSpreadElement);\n                    }\n                } else if (!(match(']') || matchKeyword('for') || matchKeyword('if'))) {\n                    expect(','); // this lexes.\n                    possiblecomprehension = false;\n                }\n            }\n        }\n\n        expect(']');\n\n        if (filter && !blocks.length) {\n            throwError({}, Messages.ComprehensionRequiresBlock);\n        }\n\n        if (blocks.length) {\n            if (elements.length !== 1) {\n                throwError({}, Messages.ComprehensionError);\n            }\n            return markerApply(marker, delegate.createComprehensionExpression(filter, blocks, elements[0]));\n        }\n        return markerApply(marker, delegate.createArrayExpression(elements));\n    }\n\n    // 11.1.5 Object Initialiser\n\n    function parsePropertyFunction(options) {\n        var previousStrict, previousYieldAllowed, previousAwaitAllowed,\n            params, defaults, body, marker = markerCreate();\n\n        previousStrict = strict;\n        previousYieldAllowed = state.yieldAllowed;\n        state.yieldAllowed = options.generator;\n        previousAwaitAllowed = state.awaitAllowed;\n        state.awaitAllowed = options.async;\n        params = options.params || [];\n        defaults = options.defaults || [];\n\n        body = parseConciseBody();\n        if (options.name && strict && isRestrictedWord(params[0].name)) {\n            throwErrorTolerant(options.name, Messages.StrictParamName);\n        }\n        strict = previousStrict;\n        state.yieldAllowed = previousYieldAllowed;\n        state.awaitAllowed = previousAwaitAllowed;\n\n        return markerApply(marker, delegate.createFunctionExpression(\n            null,\n            params,\n            defaults,\n            body,\n            options.rest || null,\n            options.generator,\n            body.type !== Syntax.BlockStatement,\n            options.async,\n            options.returnType,\n            options.typeParameters\n        ));\n    }\n\n\n    function parsePropertyMethodFunction(options) {\n        var previousStrict, tmp, method;\n\n        previousStrict = strict;\n        strict = true;\n\n        tmp = parseParams();\n\n        if (tmp.stricted) {\n            throwErrorTolerant(tmp.stricted, tmp.message);\n        }\n\n        method = parsePropertyFunction({\n            params: tmp.params,\n            defaults: tmp.defaults,\n            rest: tmp.rest,\n            generator: options.generator,\n            async: options.async,\n            returnType: tmp.returnType,\n            typeParameters: options.typeParameters\n        });\n\n        strict = previousStrict;\n\n        return method;\n    }\n\n\n    function parseObjectPropertyKey() {\n        var marker = markerCreate(),\n            token = lex(),\n            propertyKey,\n            result;\n\n        // Note: This function is called only from parseObjectProperty(), where\n        // EOF and Punctuator tokens are already filtered out.\n\n        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\n            if (strict && token.octal) {\n                throwErrorTolerant(token, Messages.StrictOctalLiteral);\n            }\n            return markerApply(marker, delegate.createLiteral(token));\n        }\n\n        if (token.type === Token.Punctuator && token.value === '[') {\n            // For computed properties we should skip the [ and ], and\n            // capture in marker only the assignment expression itself.\n            marker = markerCreate();\n            propertyKey = parseAssignmentExpression();\n            result = markerApply(marker, propertyKey);\n            expect(']');\n            return result;\n        }\n\n        return markerApply(marker, delegate.createIdentifier(token.value));\n    }\n\n    function parseObjectProperty() {\n        var token, key, id, param, computed,\n            marker = markerCreate(), returnType, typeParameters;\n\n        token = lookahead;\n        computed = (token.value === '[' && token.type === Token.Punctuator);\n\n        if (token.type === Token.Identifier || computed || matchAsync()) {\n            id = parseObjectPropertyKey();\n\n            if (match(':')) {\n                lex();\n\n                return markerApply(\n                    marker,\n                    delegate.createProperty(\n                        'init',\n                        id,\n                        parseAssignmentExpression(),\n                        false,\n                        false,\n                        computed\n                    )\n                );\n            }\n\n            if (match('(') || match('<')) {\n                if (match('<')) {\n                    typeParameters = parseTypeParameterDeclaration();\n                }\n                return markerApply(\n                    marker,\n                    delegate.createProperty(\n                        'init',\n                        id,\n                        parsePropertyMethodFunction({\n                            generator: false,\n                            async: false,\n                            typeParameters: typeParameters\n                        }),\n                        true,\n                        false,\n                        computed\n                    )\n                );\n            }\n\n            // Property Assignment: Getter and Setter.\n\n            if (token.value === 'get') {\n                computed = (lookahead.value === '[');\n                key = parseObjectPropertyKey();\n\n                expect('(');\n                expect(')');\n                if (match(':')) {\n                    returnType = parseTypeAnnotation();\n                }\n\n                return markerApply(\n                    marker,\n                    delegate.createProperty(\n                        'get',\n                        key,\n                        parsePropertyFunction({\n                            generator: false,\n                            async: false,\n                            returnType: returnType\n                        }),\n                        false,\n                        false,\n                        computed\n                    )\n                );\n            }\n\n            if (token.value === 'set') {\n                computed = (lookahead.value === '[');\n                key = parseObjectPropertyKey();\n\n                expect('(');\n                token = lookahead;\n                param = [ parseTypeAnnotatableIdentifier() ];\n                expect(')');\n                if (match(':')) {\n                    returnType = parseTypeAnnotation();\n                }\n\n                return markerApply(\n                    marker,\n                    delegate.createProperty(\n                        'set',\n                        key,\n                        parsePropertyFunction({\n                            params: param,\n                            generator: false,\n                            async: false,\n                            name: token,\n                            returnType: returnType\n                        }),\n                        false,\n                        false,\n                        computed\n                    )\n                );\n            }\n\n            if (token.value === 'async') {\n                computed = (lookahead.value === '[');\n                key = parseObjectPropertyKey();\n\n                if (match('<')) {\n                    typeParameters = parseTypeParameterDeclaration();\n                }\n\n                return markerApply(\n                    marker,\n                    delegate.createProperty(\n                        'init',\n                        key,\n                        parsePropertyMethodFunction({\n                            generator: false,\n                            async: true,\n                            typeParameters: typeParameters\n                        }),\n                        true,\n                        false,\n                        computed\n                    )\n                );\n            }\n\n            if (computed) {\n                // Computed properties can only be used with full notation.\n                throwUnexpected(lookahead);\n            }\n\n            return markerApply(\n                marker,\n                delegate.createProperty('init', id, id, false, true, false)\n            );\n        }\n\n        if (token.type === Token.EOF || token.type === Token.Punctuator) {\n            if (!match('*')) {\n                throwUnexpected(token);\n            }\n            lex();\n\n            computed = (lookahead.type === Token.Punctuator && lookahead.value === '[');\n\n            id = parseObjectPropertyKey();\n\n            if (match('<')) {\n                typeParameters = parseTypeParameterDeclaration();\n            }\n\n            if (!match('(')) {\n                throwUnexpected(lex());\n            }\n\n            return markerApply(marker, delegate.createProperty(\n                'init',\n                id,\n                parsePropertyMethodFunction({\n                    generator: true,\n                    typeParameters: typeParameters\n                }),\n                true,\n                false,\n                computed\n            ));\n        }\n        key = parseObjectPropertyKey();\n        if (match(':')) {\n            lex();\n            return markerApply(marker, delegate.createProperty('init', key, parseAssignmentExpression(), false, false, false));\n        }\n        if (match('(') || match('<')) {\n            if (match('<')) {\n                typeParameters = parseTypeParameterDeclaration();\n            }\n            return markerApply(marker, delegate.createProperty(\n                'init',\n                key,\n                parsePropertyMethodFunction({\n                    generator: false,\n                    typeParameters: typeParameters\n                }),\n                true,\n                false,\n                false\n            ));\n        }\n        throwUnexpected(lex());\n    }\n\n    function parseObjectSpreadProperty() {\n        var marker = markerCreate();\n        expect('...');\n        return markerApply(marker, delegate.createSpreadProperty(parseAssignmentExpression()));\n    }\n\n    function getFieldName(key) {\n        var toString = String;\n        if (key.type === Syntax.Identifier) {\n            return key.name;\n        }\n        return toString(key.value);\n    }\n\n    function parseObjectInitialiser() {\n        var properties = [], property, name, kind, storedKind, map = new StringMap(),\n            marker = markerCreate(), toString = String;\n\n        expect('{');\n\n        while (!match('}')) {\n            if (match('...')) {\n                property = parseObjectSpreadProperty();\n            } else {\n                property = parseObjectProperty();\n\n                if (property.key.type === Syntax.Identifier) {\n                    name = property.key.name;\n                } else {\n                    name = toString(property.key.value);\n                }\n                kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;\n\n                if (map.has(name)) {\n                    storedKind = map.get(name);\n                    if (storedKind === PropertyKind.Data) {\n                        if (strict && kind === PropertyKind.Data) {\n                            throwErrorTolerant({}, Messages.StrictDuplicateProperty);\n                        } else if (kind !== PropertyKind.Data) {\n                            throwErrorTolerant({}, Messages.AccessorDataProperty);\n                        }\n                    } else {\n                        if (kind === PropertyKind.Data) {\n                            throwErrorTolerant({}, Messages.AccessorDataProperty);\n                        } else if (storedKind & kind) {\n                            throwErrorTolerant({}, Messages.AccessorGetSet);\n                        }\n                    }\n                    map.set(name, storedKind | kind);\n                } else {\n                    map.set(name, kind);\n                }\n            }\n\n            properties.push(property);\n\n            if (!match('}')) {\n                expect(',');\n            }\n        }\n\n        expect('}');\n\n        return markerApply(marker, delegate.createObjectExpression(properties));\n    }\n\n    function parseTemplateElement(option) {\n        var marker, token;\n\n        if (lookahead.type !== Token.Template || (option.head && !lookahead.head)) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        marker = markerCreate();\n        token = lex();\n\n        if (strict && token.octal) {\n            throwError(token, Messages.StrictOctalLiteral);\n        }\n        return markerApply(marker, delegate.createTemplateElement({ raw: token.value.raw, cooked: token.value.cooked }, token.tail));\n    }\n\n    function parseTemplateLiteral() {\n        var quasi, quasis, expressions, marker = markerCreate();\n\n        quasi = parseTemplateElement({ head: true });\n        quasis = [ quasi ];\n        expressions = [];\n\n        while (!quasi.tail) {\n            expressions.push(parseExpression());\n            quasi = parseTemplateElement({ head: false });\n            quasis.push(quasi);\n        }\n\n        return markerApply(marker, delegate.createTemplateLiteral(quasis, expressions));\n    }\n\n    // 11.1.6 The Grouping Operator\n\n    function parseGroupExpression() {\n        var expr, marker, typeAnnotation;\n\n        expect('(');\n\n        ++state.parenthesizedCount;\n\n        marker = markerCreate();\n\n        expr = parseExpression();\n\n        if (match(':')) {\n            typeAnnotation = parseTypeAnnotation();\n            expr = markerApply(marker, delegate.createTypeCast(\n                expr,\n                typeAnnotation\n            ));\n        }\n\n        expect(')');\n\n        return expr;\n    }\n\n    function matchAsyncFuncExprOrDecl() {\n        var token;\n\n        if (matchAsync()) {\n            token = lookahead2();\n            if (token.type === Token.Keyword && token.value === 'function') {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    // 11.1 Primary Expressions\n\n    function parsePrimaryExpression() {\n        var marker, type, token, expr;\n\n        type = lookahead.type;\n\n        if (type === Token.Identifier) {\n            marker = markerCreate();\n            return markerApply(marker, delegate.createIdentifier(lex().value));\n        }\n\n        if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n            if (strict && lookahead.octal) {\n                throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);\n            }\n            marker = markerCreate();\n            return markerApply(marker, delegate.createLiteral(lex()));\n        }\n\n        if (type === Token.Keyword) {\n            if (matchKeyword('this')) {\n                marker = markerCreate();\n                lex();\n                return markerApply(marker, delegate.createThisExpression());\n            }\n\n            if (matchKeyword('function')) {\n                return parseFunctionExpression();\n            }\n\n            if (matchKeyword('class')) {\n                return parseClassExpression();\n            }\n\n            if (matchKeyword('super')) {\n                marker = markerCreate();\n                lex();\n                return markerApply(marker, delegate.createIdentifier('super'));\n            }\n        }\n\n        if (type === Token.BooleanLiteral) {\n            marker = markerCreate();\n            token = lex();\n            token.value = (token.value === 'true');\n            return markerApply(marker, delegate.createLiteral(token));\n        }\n\n        if (type === Token.NullLiteral) {\n            marker = markerCreate();\n            token = lex();\n            token.value = null;\n            return markerApply(marker, delegate.createLiteral(token));\n        }\n\n        if (match('[')) {\n            return parseArrayInitialiser();\n        }\n\n        if (match('{')) {\n            return parseObjectInitialiser();\n        }\n\n        if (match('(')) {\n            return parseGroupExpression();\n        }\n\n        if (match('/') || match('/=')) {\n            marker = markerCreate();\n            expr = delegate.createLiteral(scanRegExp());\n            peek();\n            return markerApply(marker, expr);\n        }\n\n        if (type === Token.Template) {\n            return parseTemplateLiteral();\n        }\n\n        if (match('<')) {\n            return parseJSXElement();\n        }\n\n        throwUnexpected(lex());\n    }\n\n    // 11.2 Left-Hand-Side Expressions\n\n    function parseArguments() {\n        var args = [], arg;\n\n        expect('(');\n\n        if (!match(')')) {\n            while (index < length) {\n                arg = parseSpreadOrAssignmentExpression();\n                args.push(arg);\n\n                if (arg.type === Syntax.SpreadElement) {\n                    if (match(')')) {\n                        break;\n                    } else {\n                        throwError({}, Messages.ElementAfterSpreadElement);\n                    }\n                }\n\n                if (match(')')) {\n                    break;\n                } else {\n                    expect(',');\n                    if (match(')')) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        expect(')');\n\n        return args;\n    }\n\n    function parseSpreadOrAssignmentExpression() {\n        if (match('...')) {\n            var marker = markerCreate();\n            lex();\n            return markerApply(marker, delegate.createSpreadElement(parseAssignmentExpression()));\n        }\n        return parseAssignmentExpression();\n    }\n\n    function parseNonComputedProperty() {\n        var marker = markerCreate(),\n            token = lex();\n\n        if (!isIdentifierName(token)) {\n            throwUnexpected(token);\n        }\n\n        return markerApply(marker, delegate.createIdentifier(token.value));\n    }\n\n    function parseNonComputedMember() {\n        expect('.');\n\n        return parseNonComputedProperty();\n    }\n\n    function parseComputedMember() {\n        var expr;\n\n        expect('[');\n\n        expr = parseExpression();\n\n        expect(']');\n\n        return expr;\n    }\n\n    function parseNewExpression() {\n        var callee, args, marker = markerCreate();\n\n        expectKeyword('new');\n        callee = parseLeftHandSideExpression();\n        args = match('(') ? parseArguments() : [];\n\n        return markerApply(marker, delegate.createNewExpression(callee, args));\n    }\n\n    function parseLeftHandSideExpressionAllowCall() {\n        var expr, args, marker = markerCreate();\n\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n        while (match('.') || match('[') || match('(') || (lookahead.type === Token.Template && lookahead.head)) {\n            if (match('(')) {\n                args = parseArguments();\n                expr = markerApply(marker, delegate.createCallExpression(expr, args));\n            } else if (match('[')) {\n                expr = markerApply(marker, delegate.createMemberExpression('[', expr, parseComputedMember()));\n            } else if (match('.')) {\n                expr = markerApply(marker, delegate.createMemberExpression('.', expr, parseNonComputedMember()));\n            } else {\n                expr = markerApply(marker, delegate.createTaggedTemplateExpression(expr, parseTemplateLiteral()));\n            }\n        }\n\n        return expr;\n    }\n\n    function parseLeftHandSideExpression() {\n        var expr, marker = markerCreate();\n\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n        while (match('.') || match('[') || (lookahead.type === Token.Template && lookahead.head)) {\n            if (match('[')) {\n                expr = markerApply(marker, delegate.createMemberExpression('[', expr, parseComputedMember()));\n            } else if (match('.')) {\n                expr = markerApply(marker, delegate.createMemberExpression('.', expr, parseNonComputedMember()));\n            } else {\n                expr = markerApply(marker, delegate.createTaggedTemplateExpression(expr, parseTemplateLiteral()));\n            }\n        }\n\n        return expr;\n    }\n\n    // 11.3 Postfix Expressions\n\n    function parsePostfixExpression() {\n        var marker = markerCreate(),\n            expr = parseLeftHandSideExpressionAllowCall(),\n            token;\n\n        if (lookahead.type !== Token.Punctuator) {\n            return expr;\n        }\n\n        if ((match('++') || match('--')) && !peekLineTerminator()) {\n            // 11.3.1, 11.3.2\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                throwErrorTolerant({}, Messages.StrictLHSPostfix);\n            }\n\n            if (!isLeftHandSide(expr)) {\n                throwError({}, Messages.InvalidLHSInAssignment);\n            }\n\n            token = lex();\n            expr = markerApply(marker, delegate.createPostfixExpression(token.value, expr));\n        }\n\n        return expr;\n    }\n\n    // 11.4 Unary Operators\n\n    function parseUnaryExpression() {\n        var marker, token, expr;\n\n        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n            return parsePostfixExpression();\n        }\n\n        if (match('++') || match('--')) {\n            marker = markerCreate();\n            token = lex();\n            expr = parseUnaryExpression();\n            // 11.4.4, 11.4.5\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                throwErrorTolerant({}, Messages.StrictLHSPrefix);\n            }\n\n            if (!isLeftHandSide(expr)) {\n                throwError({}, Messages.InvalidLHSInAssignment);\n            }\n\n            return markerApply(marker, delegate.createUnaryExpression(token.value, expr));\n        }\n\n        if (match('+') || match('-') || match('~') || match('!')) {\n            marker = markerCreate();\n            token = lex();\n            expr = parseUnaryExpression();\n            return markerApply(marker, delegate.createUnaryExpression(token.value, expr));\n        }\n\n        if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n            marker = markerCreate();\n            token = lex();\n            expr = parseUnaryExpression();\n            expr = markerApply(marker, delegate.createUnaryExpression(token.value, expr));\n            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {\n                throwErrorTolerant({}, Messages.StrictDelete);\n            }\n            return expr;\n        }\n\n        return parsePostfixExpression();\n    }\n\n    function binaryPrecedence(token, allowIn) {\n        var prec = 0;\n\n        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n            return 0;\n        }\n\n        switch (token.value) {\n        case '||':\n            prec = 1;\n            break;\n\n        case '&&':\n            prec = 2;\n            break;\n\n        case '|':\n            prec = 3;\n            break;\n\n        case '^':\n            prec = 4;\n            break;\n\n        case '&':\n            prec = 5;\n            break;\n\n        case '==':\n        case '!=':\n        case '===':\n        case '!==':\n            prec = 6;\n            break;\n\n        case '<':\n        case '>':\n        case '<=':\n        case '>=':\n        case 'instanceof':\n            prec = 7;\n            break;\n\n        case 'in':\n            prec = allowIn ? 7 : 0;\n            break;\n\n        case '<<':\n        case '>>':\n        case '>>>':\n            prec = 8;\n            break;\n\n        case '+':\n        case '-':\n            prec = 9;\n            break;\n\n        case '*':\n        case '/':\n        case '%':\n            prec = 11;\n            break;\n\n        default:\n            break;\n        }\n\n        return prec;\n    }\n\n    // 11.5 Multiplicative Operators\n    // 11.6 Additive Operators\n    // 11.7 Bitwise Shift Operators\n    // 11.8 Relational Operators\n    // 11.9 Equality Operators\n    // 11.10 Binary Bitwise Operators\n    // 11.11 Binary Logical Operators\n\n    function parseBinaryExpression() {\n        var expr, token, prec, previousAllowIn, stack, right, operator, left, i,\n            marker, markers;\n\n        previousAllowIn = state.allowIn;\n        state.allowIn = true;\n\n        marker = markerCreate();\n        left = parseUnaryExpression();\n\n        token = lookahead;\n        prec = binaryPrecedence(token, previousAllowIn);\n        if (prec === 0) {\n            return left;\n        }\n        token.prec = prec;\n        lex();\n\n        markers = [marker, markerCreate()];\n        right = parseUnaryExpression();\n\n        stack = [left, token, right];\n\n        while ((prec = binaryPrecedence(lookahead, previousAllowIn)) > 0) {\n\n            // Reduce: make a binary expression from the three topmost entries.\n            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\n                right = stack.pop();\n                operator = stack.pop().value;\n                left = stack.pop();\n                expr = delegate.createBinaryExpression(operator, left, right);\n                markers.pop();\n                marker = markers.pop();\n                markerApply(marker, expr);\n                stack.push(expr);\n                markers.push(marker);\n            }\n\n            // Shift.\n            token = lex();\n            token.prec = prec;\n            stack.push(token);\n            markers.push(markerCreate());\n            expr = parseUnaryExpression();\n            stack.push(expr);\n        }\n\n        state.allowIn = previousAllowIn;\n\n        // Final reduce to clean-up the stack.\n        i = stack.length - 1;\n        expr = stack[i];\n        markers.pop();\n        while (i > 1) {\n            expr = delegate.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n            i -= 2;\n            marker = markers.pop();\n            markerApply(marker, expr);\n        }\n\n        return expr;\n    }\n\n\n    // 11.12 Conditional Operator\n\n    function parseConditionalExpression() {\n        var expr, previousAllowIn, consequent, alternate, marker = markerCreate();\n        expr = parseBinaryExpression();\n\n        if (match('?')) {\n            lex();\n            previousAllowIn = state.allowIn;\n            state.allowIn = true;\n            consequent = parseAssignmentExpression();\n            state.allowIn = previousAllowIn;\n            expect(':');\n            alternate = parseAssignmentExpression();\n\n            expr = markerApply(marker, delegate.createConditionalExpression(expr, consequent, alternate));\n        }\n\n        return expr;\n    }\n\n    // 11.13 Assignment Operators\n\n    // 12.14.5 AssignmentPattern\n\n    function reinterpretAsAssignmentBindingPattern(expr) {\n        var i, len, property, element;\n\n        if (expr.type === Syntax.ObjectExpression) {\n            expr.type = Syntax.ObjectPattern;\n            for (i = 0, len = expr.properties.length; i < len; i += 1) {\n                property = expr.properties[i];\n                if (property.type === Syntax.SpreadProperty) {\n                    if (i < len - 1) {\n                        throwError({}, Messages.PropertyAfterSpreadProperty);\n                    }\n                    reinterpretAsAssignmentBindingPattern(property.argument);\n                } else {\n                    if (property.kind !== 'init') {\n                        throwError({}, Messages.InvalidLHSInAssignment);\n                    }\n                    reinterpretAsAssignmentBindingPattern(property.value);\n                }\n            }\n        } else if (expr.type === Syntax.ArrayExpression) {\n            expr.type = Syntax.ArrayPattern;\n            for (i = 0, len = expr.elements.length; i < len; i += 1) {\n                element = expr.elements[i];\n                /* istanbul ignore else */\n                if (element) {\n                    reinterpretAsAssignmentBindingPattern(element);\n                }\n            }\n        } else if (expr.type === Syntax.Identifier) {\n            if (isRestrictedWord(expr.name)) {\n                throwError({}, Messages.InvalidLHSInAssignment);\n            }\n        } else if (expr.type === Syntax.SpreadElement) {\n            reinterpretAsAssignmentBindingPattern(expr.argument);\n            if (expr.argument.type === Syntax.ObjectPattern) {\n                throwError({}, Messages.ObjectPatternAsSpread);\n            }\n        } else {\n            /* istanbul ignore else */\n            if (expr.type !== Syntax.MemberExpression && expr.type !== Syntax.CallExpression && expr.type !== Syntax.NewExpression) {\n                throwError({}, Messages.InvalidLHSInAssignment);\n            }\n        }\n    }\n\n    // 13.2.3 BindingPattern\n\n    function reinterpretAsDestructuredParameter(options, expr) {\n        var i, len, property, element;\n\n        if (expr.type === Syntax.ObjectExpression) {\n            expr.type = Syntax.ObjectPattern;\n            for (i = 0, len = expr.properties.length; i < len; i += 1) {\n                property = expr.properties[i];\n                if (property.type === Syntax.SpreadProperty) {\n                    if (i < len - 1) {\n                        throwError({}, Messages.PropertyAfterSpreadProperty);\n                    }\n                    reinterpretAsDestructuredParameter(options, property.argument);\n                } else {\n                    if (property.kind !== 'init') {\n                        throwError({}, Messages.InvalidLHSInFormalsList);\n                    }\n                    reinterpretAsDestructuredParameter(options, property.value);\n                }\n            }\n        } else if (expr.type === Syntax.ArrayExpression) {\n            expr.type = Syntax.ArrayPattern;\n            for (i = 0, len = expr.elements.length; i < len; i += 1) {\n                element = expr.elements[i];\n                if (element) {\n                    reinterpretAsDestructuredParameter(options, element);\n                }\n            }\n        } else if (expr.type === Syntax.Identifier) {\n            validateParam(options, expr, expr.name);\n        } else if (expr.type === Syntax.SpreadElement) {\n            // BindingRestElement only allows BindingIdentifier\n            if (expr.argument.type !== Syntax.Identifier) {\n                throwError({}, Messages.InvalidLHSInFormalsList);\n            }\n            validateParam(options, expr.argument, expr.argument.name);\n        } else {\n            throwError({}, Messages.InvalidLHSInFormalsList);\n        }\n    }\n\n    function reinterpretAsCoverFormalsList(expressions) {\n        var i, len, param, params, defaults, defaultCount, options, rest;\n\n        params = [];\n        defaults = [];\n        defaultCount = 0;\n        rest = null;\n        options = {\n            paramSet: new StringMap()\n        };\n\n        for (i = 0, len = expressions.length; i < len; i += 1) {\n            param = expressions[i];\n            if (param.type === Syntax.Identifier) {\n                params.push(param);\n                defaults.push(null);\n                validateParam(options, param, param.name);\n            } else if (param.type === Syntax.ObjectExpression || param.type === Syntax.ArrayExpression) {\n                reinterpretAsDestructuredParameter(options, param);\n                params.push(param);\n                defaults.push(null);\n            } else if (param.type === Syntax.SpreadElement) {\n                assert(i === len - 1, 'It is guaranteed that SpreadElement is last element by parseExpression');\n                if (param.argument.type !== Syntax.Identifier) {\n                    throwError({}, Messages.InvalidLHSInFormalsList);\n                }\n                reinterpretAsDestructuredParameter(options, param.argument);\n                rest = param.argument;\n            } else if (param.type === Syntax.AssignmentExpression) {\n                params.push(param.left);\n                defaults.push(param.right);\n                ++defaultCount;\n                validateParam(options, param.left, param.left.name);\n            } else {\n                return null;\n            }\n        }\n\n        if (options.message === Messages.StrictParamDupe) {\n            throwError(\n                strict ? options.stricted : options.firstRestricted,\n                options.message\n            );\n        }\n\n        if (defaultCount === 0) {\n            defaults = [];\n        }\n\n        return {\n            params: params,\n            defaults: defaults,\n            rest: rest,\n            stricted: options.stricted,\n            firstRestricted: options.firstRestricted,\n            message: options.message\n        };\n    }\n\n    function parseArrowFunctionExpression(options, marker) {\n        var previousStrict, previousYieldAllowed, previousAwaitAllowed, body;\n\n        expect('=>');\n\n        previousStrict = strict;\n        previousYieldAllowed = state.yieldAllowed;\n        state.yieldAllowed = false;\n        previousAwaitAllowed = state.awaitAllowed;\n        state.awaitAllowed = !!options.async;\n        body = parseConciseBody();\n\n        if (strict && options.firstRestricted) {\n            throwError(options.firstRestricted, options.message);\n        }\n        if (strict && options.stricted) {\n            throwErrorTolerant(options.stricted, options.message);\n        }\n\n        strict = previousStrict;\n        state.yieldAllowed = previousYieldAllowed;\n        state.awaitAllowed = previousAwaitAllowed;\n\n        return markerApply(marker, delegate.createArrowFunctionExpression(\n            options.params,\n            options.defaults,\n            body,\n            options.rest,\n            body.type !== Syntax.BlockStatement,\n            !!options.async\n        ));\n    }\n\n    function parseAssignmentExpression() {\n        var marker, expr, token, params, oldParenthesizedCount,\n            startsWithParen = false, backtrackToken = lookahead,\n            possiblyAsync = false;\n\n        if (matchYield()) {\n            return parseYieldExpression();\n        }\n\n        if (matchAwait()) {\n            return parseAwaitExpression();\n        }\n\n        oldParenthesizedCount = state.parenthesizedCount;\n\n        marker = markerCreate();\n\n        if (matchAsyncFuncExprOrDecl()) {\n            return parseFunctionExpression();\n        }\n\n        if (matchAsync()) {\n            // We can't be completely sure that this 'async' token is\n            // actually a contextual keyword modifying a function\n            // expression, so we might have to un-lex() it later by\n            // calling rewind(backtrackToken).\n            possiblyAsync = true;\n            lex();\n        }\n\n        if (match('(')) {\n            token = lookahead2();\n            if ((token.type === Token.Punctuator && token.value === ')') || token.value === '...') {\n                params = parseParams();\n                if (!match('=>')) {\n                    throwUnexpected(lex());\n                }\n                params.async = possiblyAsync;\n                return parseArrowFunctionExpression(params, marker);\n            }\n            startsWithParen = true;\n        }\n\n        token = lookahead;\n\n        // If the 'async' keyword is not followed by a '(' character or an\n        // identifier, then it can't be an arrow function modifier, and we\n        // should interpret it as a normal identifer.\n        if (possiblyAsync && !match('(') && token.type !== Token.Identifier) {\n            possiblyAsync = false;\n            rewind(backtrackToken);\n        }\n\n        expr = parseConditionalExpression();\n\n        if (match('=>') &&\n                (state.parenthesizedCount === oldParenthesizedCount ||\n                state.parenthesizedCount === (oldParenthesizedCount + 1))) {\n            if (expr.type === Syntax.Identifier) {\n                params = reinterpretAsCoverFormalsList([ expr ]);\n            } else if (expr.type === Syntax.AssignmentExpression ||\n                    expr.type === Syntax.ArrayExpression ||\n                    expr.type === Syntax.ObjectExpression) {\n                if (!startsWithParen) {\n                    throwUnexpected(lex());\n                }\n                params = reinterpretAsCoverFormalsList([ expr ]);\n            } else if (expr.type === Syntax.SequenceExpression) {\n                params = reinterpretAsCoverFormalsList(expr.expressions);\n            }\n            if (params) {\n                params.async = possiblyAsync;\n                return parseArrowFunctionExpression(params, marker);\n            }\n        }\n\n        // If we haven't returned by now, then the 'async' keyword was not\n        // a function modifier, and we should rewind and interpret it as a\n        // normal identifier.\n        if (possiblyAsync) {\n            possiblyAsync = false;\n            rewind(backtrackToken);\n            expr = parseConditionalExpression();\n        }\n\n        if (matchAssign()) {\n            // 11.13.1\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                throwErrorTolerant(token, Messages.StrictLHSAssignment);\n            }\n\n            // ES.next draf 11.13 Runtime Semantics step 1\n            if (match('=') && (expr.type === Syntax.ObjectExpression || expr.type === Syntax.ArrayExpression)) {\n                reinterpretAsAssignmentBindingPattern(expr);\n            } else if (!isLeftHandSide(expr)) {\n                throwError({}, Messages.InvalidLHSInAssignment);\n            }\n\n            expr = markerApply(marker, delegate.createAssignmentExpression(lex().value, expr, parseAssignmentExpression()));\n        }\n\n        return expr;\n    }\n\n    // 11.14 Comma Operator\n\n    function parseExpression() {\n        var marker, expr, expressions, sequence, spreadFound, possibleArrow;\n\n        marker = markerCreate();\n        expr = parseAssignmentExpression();\n        expressions = [ expr ];\n\n        if (match(',')) {\n            while (index < length) {\n                if (!match(',')) {\n                    break;\n                }\n\n                lex();\n\n                if (match(')')) {\n                    possibleArrow = lookahead2();\n                    if (\n                        possibleArrow.type === Token.Punctuator &&\n                        possibleArrow.value === '=>'\n                    ) {\n                        break;\n                    }\n                }\n\n                expr = parseSpreadOrAssignmentExpression();\n                expressions.push(expr);\n\n                if (expr.type === Syntax.SpreadElement) {\n                    spreadFound = true;\n                    if (!match(')')) {\n                        throwError({}, Messages.ElementAfterSpreadElement);\n                    }\n                    break;\n                }\n            }\n\n            if (expressions.length > 1) {\n                sequence = markerApply(marker, delegate.createSequenceExpression(expressions));\n            }\n        }\n\n        if (spreadFound && lookahead2().value !== '=>') {\n            throwError({}, Messages.IllegalSpread);\n        }\n\n        return sequence || expr;\n    }\n\n    // 12.1 Block\n\n    function parseStatementList() {\n        var list = [],\n            statement;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            statement = parseSourceElement();\n            if (typeof statement === 'undefined') {\n                break;\n            }\n            list.push(statement);\n        }\n\n        return list;\n    }\n\n    function parseBlock() {\n        var block, marker = markerCreate();\n\n        expect('{');\n\n        block = parseStatementList();\n\n        expect('}');\n\n        return markerApply(marker, delegate.createBlockStatement(block));\n    }\n\n    // 12.2 Variable Statement\n\n    function parseTypeParameterDeclaration() {\n        var marker = markerCreate(), paramTypes = [];\n\n        expect('<');\n        while (!match('>')) {\n            paramTypes.push(parseTypeAnnotatableIdentifier());\n            if (!match('>')) {\n                expect(',');\n            }\n        }\n        expect('>');\n\n        return markerApply(marker, delegate.createTypeParameterDeclaration(\n            paramTypes\n        ));\n    }\n\n    function parseTypeParameterInstantiation() {\n        var marker = markerCreate(), oldInType = state.inType, paramTypes = [];\n\n        state.inType = true;\n\n        expect('<');\n        while (!match('>')) {\n            paramTypes.push(parseType());\n            if (!match('>')) {\n                expect(',');\n            }\n        }\n        expect('>');\n\n        state.inType = oldInType;\n\n        return markerApply(marker, delegate.createTypeParameterInstantiation(\n            paramTypes\n        ));\n    }\n\n    function parseObjectTypeIndexer(marker, isStatic) {\n        var id, key, value;\n\n        expect('[');\n        id = parseObjectPropertyKey();\n        expect(':');\n        key = parseType();\n        expect(']');\n        expect(':');\n        value = parseType();\n\n        return markerApply(marker, delegate.createObjectTypeIndexer(\n            id,\n            key,\n            value,\n            isStatic\n        ));\n    }\n\n    function parseObjectTypeMethodish(marker) {\n        var params = [], rest = null, returnType, typeParameters = null;\n        if (match('<')) {\n            typeParameters = parseTypeParameterDeclaration();\n        }\n\n        expect('(');\n        while (lookahead.type === Token.Identifier) {\n            params.push(parseFunctionTypeParam());\n            if (!match(')')) {\n                expect(',');\n            }\n        }\n\n        if (match('...')) {\n            lex();\n            rest = parseFunctionTypeParam();\n        }\n        expect(')');\n        expect(':');\n        returnType = parseType();\n\n        return markerApply(marker, delegate.createFunctionTypeAnnotation(\n            params,\n            returnType,\n            rest,\n            typeParameters\n        ));\n    }\n\n    function parseObjectTypeMethod(marker, isStatic, key) {\n        var optional = false, value;\n        value = parseObjectTypeMethodish(marker);\n\n        return markerApply(marker, delegate.createObjectTypeProperty(\n            key,\n            value,\n            optional,\n            isStatic\n        ));\n    }\n\n    function parseObjectTypeCallProperty(marker, isStatic) {\n        var valueMarker = markerCreate();\n        return markerApply(marker, delegate.createObjectTypeCallProperty(\n            parseObjectTypeMethodish(valueMarker),\n            isStatic\n        ));\n    }\n\n    function parseObjectType(allowStatic) {\n        var callProperties = [], indexers = [], marker, optional = false,\n            properties = [], propertyKey, propertyTypeAnnotation,\n            token, isStatic, matchStatic;\n\n        expect('{');\n\n        while (!match('}')) {\n            marker = markerCreate();\n            matchStatic =\n                   strict\n                   ? matchKeyword('static')\n                   : matchContextualKeyword('static');\n\n            if (allowStatic && matchStatic) {\n                token = lex();\n                isStatic = true;\n            }\n\n            if (match('[')) {\n                indexers.push(parseObjectTypeIndexer(marker, isStatic));\n            } else if (match('(') || match('<')) {\n                callProperties.push(parseObjectTypeCallProperty(marker, allowStatic));\n            } else {\n                if (isStatic && match(':')) {\n                    propertyKey = markerApply(marker, delegate.createIdentifier(token));\n                    throwErrorTolerant(token, Messages.StrictReservedWord);\n                } else {\n                    propertyKey = parseObjectPropertyKey();\n                }\n                if (match('<') || match('(')) {\n                    // This is a method property\n                    properties.push(parseObjectTypeMethod(marker, isStatic, propertyKey));\n                } else {\n                    if (match('?')) {\n                        lex();\n                        optional = true;\n                    }\n                    expect(':');\n                    propertyTypeAnnotation = parseType();\n                    properties.push(markerApply(marker, delegate.createObjectTypeProperty(\n                        propertyKey,\n                        propertyTypeAnnotation,\n                        optional,\n                        isStatic\n                    )));\n                }\n            }\n\n            if (match(';') || match(',')) {\n                lex();\n            } else if (!match('}')) {\n                throwUnexpected(lookahead);\n            }\n        }\n\n        expect('}');\n\n        return delegate.createObjectTypeAnnotation(\n            properties,\n            indexers,\n            callProperties\n        );\n    }\n\n    function parseGenericType() {\n        var marker = markerCreate(),\n            typeParameters = null, typeIdentifier;\n\n        typeIdentifier = parseVariableIdentifier();\n\n        while (match('.')) {\n            expect('.');\n            typeIdentifier = markerApply(marker, delegate.createQualifiedTypeIdentifier(\n                typeIdentifier,\n                parseVariableIdentifier()\n            ));\n        }\n\n        if (match('<')) {\n            typeParameters = parseTypeParameterInstantiation();\n        }\n\n        return markerApply(marker, delegate.createGenericTypeAnnotation(\n            typeIdentifier,\n            typeParameters\n        ));\n    }\n\n    function parseVoidType() {\n        var marker = markerCreate();\n        expectKeyword('void');\n        return markerApply(marker, delegate.createVoidTypeAnnotation());\n    }\n\n    function parseTypeofType() {\n        var argument, marker = markerCreate();\n        expectKeyword('typeof');\n        argument = parsePrimaryType();\n        return markerApply(marker, delegate.createTypeofTypeAnnotation(\n            argument\n        ));\n    }\n\n    function parseTupleType() {\n        var marker = markerCreate(), types = [];\n        expect('[');\n        // We allow trailing commas\n        while (index < length && !match(']')) {\n            types.push(parseType());\n            if (match(']')) {\n                break;\n            }\n            expect(',');\n        }\n        expect(']');\n        return markerApply(marker, delegate.createTupleTypeAnnotation(\n            types\n        ));\n    }\n\n    function parseFunctionTypeParam() {\n        var marker = markerCreate(), name, optional = false, typeAnnotation;\n        name = parseVariableIdentifier();\n        if (match('?')) {\n            lex();\n            optional = true;\n        }\n        expect(':');\n        typeAnnotation = parseType();\n        return markerApply(marker, delegate.createFunctionTypeParam(\n            name,\n            typeAnnotation,\n            optional\n        ));\n    }\n\n    function parseFunctionTypeParams() {\n        var ret = { params: [], rest: null };\n        while (lookahead.type === Token.Identifier) {\n            ret.params.push(parseFunctionTypeParam());\n            if (!match(')')) {\n                expect(',');\n            }\n        }\n\n        if (match('...')) {\n            lex();\n            ret.rest = parseFunctionTypeParam();\n        }\n        return ret;\n    }\n\n    // The parsing of types roughly parallels the parsing of expressions, and\n    // primary types are kind of like primary expressions...they're the\n    // primitives with which other types are constructed.\n    function parsePrimaryType() {\n        var params = null, returnType = null,\n            marker = markerCreate(), rest = null, tmp,\n            typeParameters, token, type, isGroupedType = false;\n\n        switch (lookahead.type) {\n        case Token.Identifier:\n            switch (lookahead.value) {\n            case 'any':\n                lex();\n                return markerApply(marker, delegate.createAnyTypeAnnotation());\n            case 'bool':  // fallthrough\n            case 'boolean':\n                lex();\n                return markerApply(marker, delegate.createBooleanTypeAnnotation());\n            case 'number':\n                lex();\n                return markerApply(marker, delegate.createNumberTypeAnnotation());\n            case 'string':\n                lex();\n                return markerApply(marker, delegate.createStringTypeAnnotation());\n            }\n            return markerApply(marker, parseGenericType());\n        case Token.Punctuator:\n            switch (lookahead.value) {\n            case '{':\n                return markerApply(marker, parseObjectType());\n            case '[':\n                return parseTupleType();\n            case '<':\n                typeParameters = parseTypeParameterDeclaration();\n                expect('(');\n                tmp = parseFunctionTypeParams();\n                params = tmp.params;\n                rest = tmp.rest;\n                expect(')');\n\n                expect('=>');\n\n                returnType = parseType();\n\n                return markerApply(marker, delegate.createFunctionTypeAnnotation(\n                    params,\n                    returnType,\n                    rest,\n                    typeParameters\n                ));\n            case '(':\n                lex();\n                // Check to see if this is actually a grouped type\n                if (!match(')') && !match('...')) {\n                    if (lookahead.type === Token.Identifier) {\n                        token = lookahead2();\n                        isGroupedType = token.value !== '?' && token.value !== ':';\n                    } else {\n                        isGroupedType = true;\n                    }\n                }\n\n                if (isGroupedType) {\n                    type = parseType();\n                    expect(')');\n\n                    // If we see a => next then someone was probably confused about\n                    // function types, so we can provide a better error message\n                    if (match('=>')) {\n                        throwError({}, Messages.ConfusedAboutFunctionType);\n                    }\n\n                    return type;\n                }\n\n                tmp = parseFunctionTypeParams();\n                params = tmp.params;\n                rest = tmp.rest;\n\n                expect(')');\n\n                expect('=>');\n\n                returnType = parseType();\n\n                return markerApply(marker, delegate.createFunctionTypeAnnotation(\n                    params,\n                    returnType,\n                    rest,\n                    null /* typeParameters */\n                ));\n            }\n            break;\n        case Token.Keyword:\n            switch (lookahead.value) {\n            case 'void':\n                return markerApply(marker, parseVoidType());\n            case 'typeof':\n                return markerApply(marker, parseTypeofType());\n            }\n            break;\n        case Token.StringLiteral:\n            token = lex();\n            if (token.octal) {\n                throwError(token, Messages.StrictOctalLiteral);\n            }\n            return markerApply(marker, delegate.createStringLiteralTypeAnnotation(\n                token\n            ));\n        }\n\n        throwUnexpected(lookahead);\n    }\n\n    function parsePostfixType() {\n        var marker = markerCreate(), t = parsePrimaryType();\n        if (match('[')) {\n            expect('[');\n            expect(']');\n            return markerApply(marker, delegate.createArrayTypeAnnotation(t));\n        }\n        return t;\n    }\n\n    function parsePrefixType() {\n        var marker = markerCreate();\n        if (match('?')) {\n            lex();\n            return markerApply(marker, delegate.createNullableTypeAnnotation(\n                parsePrefixType()\n            ));\n        }\n        return parsePostfixType();\n    }\n\n\n    function parseIntersectionType() {\n        var marker = markerCreate(), type, types;\n        type = parsePrefixType();\n        types = [type];\n        while (match('&')) {\n            lex();\n            types.push(parsePrefixType());\n        }\n\n        return types.length === 1 ?\n                type :\n                markerApply(marker, delegate.createIntersectionTypeAnnotation(\n                    types\n                ));\n    }\n\n    function parseUnionType() {\n        var marker = markerCreate(), type, types;\n        type = parseIntersectionType();\n        types = [type];\n        while (match('|')) {\n            lex();\n            types.push(parseIntersectionType());\n        }\n        return types.length === 1 ?\n                type :\n                markerApply(marker, delegate.createUnionTypeAnnotation(\n                    types\n                ));\n    }\n\n    function parseType() {\n        var oldInType = state.inType, type;\n        state.inType = true;\n\n        type = parseUnionType();\n\n        state.inType = oldInType;\n        return type;\n    }\n\n    function parseTypeAnnotation() {\n        var marker = markerCreate(), type;\n\n        expect(':');\n        type = parseType();\n\n        return markerApply(marker, delegate.createTypeAnnotation(type));\n    }\n\n    function parseVariableIdentifier() {\n        var marker = markerCreate(),\n            token = lex();\n\n        if (token.type !== Token.Identifier) {\n            throwUnexpected(token);\n        }\n\n        return markerApply(marker, delegate.createIdentifier(token.value));\n    }\n\n    function parseTypeAnnotatableIdentifier(requireTypeAnnotation, canBeOptionalParam) {\n        var marker = markerCreate(),\n            ident = parseVariableIdentifier(),\n            isOptionalParam = false;\n\n        if (canBeOptionalParam && match('?')) {\n            expect('?');\n            isOptionalParam = true;\n        }\n\n        if (requireTypeAnnotation || match(':')) {\n            ident.typeAnnotation = parseTypeAnnotation();\n            ident = markerApply(marker, ident);\n        }\n\n        if (isOptionalParam) {\n            ident.optional = true;\n            ident = markerApply(marker, ident);\n        }\n\n        return ident;\n    }\n\n    function parseVariableDeclaration(kind) {\n        var id,\n            marker = markerCreate(),\n            init = null,\n            typeAnnotationMarker = markerCreate();\n        if (match('{')) {\n            id = parseObjectInitialiser();\n            reinterpretAsAssignmentBindingPattern(id);\n            if (match(':')) {\n                id.typeAnnotation = parseTypeAnnotation();\n                markerApply(typeAnnotationMarker, id);\n            }\n        } else if (match('[')) {\n            id = parseArrayInitialiser();\n            reinterpretAsAssignmentBindingPattern(id);\n            if (match(':')) {\n                id.typeAnnotation = parseTypeAnnotation();\n                markerApply(typeAnnotationMarker, id);\n            }\n        } else {\n            /* istanbul ignore next */\n            id = state.allowKeyword ? parseNonComputedProperty() : parseTypeAnnotatableIdentifier();\n            // 12.2.1\n            if (strict && isRestrictedWord(id.name)) {\n                throwErrorTolerant({}, Messages.StrictVarName);\n            }\n        }\n\n        if (kind === 'const') {\n            if (!match('=')) {\n                throwError({}, Messages.NoUninitializedConst);\n            }\n            expect('=');\n            init = parseAssignmentExpression();\n        } else if (match('=')) {\n            lex();\n            init = parseAssignmentExpression();\n        }\n\n        return markerApply(marker, delegate.createVariableDeclarator(id, init));\n    }\n\n    function parseVariableDeclarationList(kind) {\n        var list = [];\n\n        do {\n            list.push(parseVariableDeclaration(kind));\n            if (!match(',')) {\n                break;\n            }\n            lex();\n        } while (index < length);\n\n        return list;\n    }\n\n    function parseVariableStatement() {\n        var declarations, marker = markerCreate();\n\n        expectKeyword('var');\n\n        declarations = parseVariableDeclarationList();\n\n        consumeSemicolon();\n\n        return markerApply(marker, delegate.createVariableDeclaration(declarations, 'var'));\n    }\n\n    // kind may be `const` or `let`\n    // Both are experimental and not in the specification yet.\n    // see http://wiki.ecmascript.org/doku.php?id=harmony:const\n    // and http://wiki.ecmascript.org/doku.php?id=harmony:let\n    function parseConstLetDeclaration(kind) {\n        var declarations, marker = markerCreate();\n\n        expectKeyword(kind);\n\n        declarations = parseVariableDeclarationList(kind);\n\n        consumeSemicolon();\n\n        return markerApply(marker, delegate.createVariableDeclaration(declarations, kind));\n    }\n\n    // people.mozilla.org/~jorendorff/es6-draft.html\n\n    function parseModuleSpecifier() {\n        var marker = markerCreate(),\n            specifier;\n\n        if (lookahead.type !== Token.StringLiteral) {\n            throwError({}, Messages.InvalidModuleSpecifier);\n        }\n        specifier = delegate.createLiteral(lex());\n        return markerApply(marker, specifier);\n    }\n\n    function parseExportBatchSpecifier() {\n        var marker = markerCreate();\n        expect('*');\n        return markerApply(marker, delegate.createExportBatchSpecifier());\n    }\n\n    function parseExportSpecifier() {\n        var id, name = null, marker = markerCreate();\n        if (matchKeyword('default')) {\n            lex();\n            id = markerApply(marker, delegate.createIdentifier('default'));\n            // export {default} from \"something\";\n        } else {\n            id = parseVariableIdentifier();\n        }\n        if (matchContextualKeyword('as')) {\n            lex();\n            name = parseNonComputedProperty();\n        }\n\n        return markerApply(marker, delegate.createExportSpecifier(id, name));\n    }\n\n    function parseExportDeclaration() {\n        var declaration = null,\n            possibleIdentifierToken, sourceElement,\n            isExportFromIdentifier,\n            src = null, specifiers = [],\n            marker = markerCreate(),\n            token2,\n            exportKind = 'value';\n\n        expectKeyword('export');\n\n        if (matchKeyword('default')) {\n            // covers:\n            // export default ...\n            lex();\n            if (matchKeyword('function') || matchKeyword('class')) {\n                possibleIdentifierToken = lookahead2();\n                if (isIdentifierName(possibleIdentifierToken)) {\n                    // covers:\n                    // export default function foo () {}\n                    // export default class foo {}\n                    sourceElement = parseSourceElement();\n                    return markerApply(marker, delegate.createExportDeclaration(true, sourceElement, [sourceElement.id], null, exportKind));\n                }\n                // covers:\n                // export default function () {}\n                // export default class {}\n                switch (lookahead.value) {\n                case 'class':\n                    return markerApply(marker, delegate.createExportDeclaration(true, parseClassExpression(), [], null, exportKind));\n                case 'function':\n                    return markerApply(marker, delegate.createExportDeclaration(true, parseFunctionExpression(), [], null, exportKind));\n                }\n            }\n\n            if (matchContextualKeyword('from')) {\n                throwError({}, Messages.UnexpectedToken, lookahead.value);\n            }\n\n            // covers:\n            // export default {};\n            // export default [];\n            if (match('{')) {\n                declaration = parseObjectInitialiser();\n            } else if (match('[')) {\n                declaration = parseArrayInitialiser();\n            } else {\n                declaration = parseAssignmentExpression();\n            }\n            consumeSemicolon();\n            return markerApply(marker, delegate.createExportDeclaration(true, declaration, [], null, exportKind));\n        }\n\n        // non-default export\n        if (lookahead.type === Token.Keyword || matchContextualKeyword('type')) {\n            // covers:\n            // export var f = 1;\n            switch (lookahead.value) {\n            case 'type':\n                exportKind = 'type';\n\n                token2 = lookahead2();\n                if (token2.type === Token.Punctuator && token2.value === '{') {\n                    lex();\n                    break;\n                }\n                // falls through\n            case 'let':\n            case 'const':\n            case 'var':\n            case 'class':\n            case 'function':\n                return markerApply(marker, delegate.createExportDeclaration(false, parseSourceElement(), specifiers, null, exportKind));\n            }\n        }\n\n        if (match('*')) {\n            // covers:\n            // export * from \"foo\";\n            specifiers.push(parseExportBatchSpecifier());\n\n            if (!matchContextualKeyword('from')) {\n                throwError({}, lookahead.value ?\n                        Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n            }\n            lex();\n            src = parseModuleSpecifier();\n            consumeSemicolon();\n\n            return markerApply(marker, delegate.createExportDeclaration(false, null, specifiers, src, exportKind));\n        }\n\n        expect('{');\n        if (!match('}')) {\n            do {\n                isExportFromIdentifier = isExportFromIdentifier || matchKeyword('default');\n                specifiers.push(parseExportSpecifier());\n            } while (match(',') && lex());\n        }\n        expect('}');\n\n        if (matchContextualKeyword('from')) {\n            // covering:\n            // export {default} from \"foo\";\n            // export {foo} from \"foo\";\n            lex();\n            src = parseModuleSpecifier();\n            consumeSemicolon();\n        } else if (isExportFromIdentifier) {\n            // covering:\n            // export {default}; // missing fromClause\n            throwError({}, lookahead.value ?\n                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n        } else {\n            // cover\n            // export {foo};\n            consumeSemicolon();\n        }\n        return markerApply(marker, delegate.createExportDeclaration(false, declaration, specifiers, src, exportKind));\n    }\n\n\n    function parseImportSpecifier() {\n        // import {<foo as bar>} ...;\n        var id, name = null, marker = markerCreate();\n\n        id = parseNonComputedProperty();\n        if (matchContextualKeyword('as')) {\n            lex();\n            name = parseVariableIdentifier();\n        }\n\n        return markerApply(marker, delegate.createImportSpecifier(id, name));\n    }\n\n    function parseNamedImports() {\n        var specifiers = [];\n        // {foo, bar as bas}\n        expect('{');\n        if (!match('}')) {\n            do {\n                specifiers.push(parseImportSpecifier());\n            } while (match(',') && lex());\n        }\n        expect('}');\n        return specifiers;\n    }\n\n    function parseImportDefaultSpecifier() {\n        // import <foo> ...;\n        var id, marker = markerCreate();\n\n        id = parseNonComputedProperty();\n\n        return markerApply(marker, delegate.createImportDefaultSpecifier(id));\n    }\n\n    function parseImportNamespaceSpecifier() {\n        // import <* as foo> ...;\n        var id, marker = markerCreate();\n\n        expect('*');\n        if (!matchContextualKeyword('as')) {\n            throwError({}, Messages.NoAsAfterImportNamespace);\n        }\n        lex();\n        id = parseNonComputedProperty();\n\n        return markerApply(marker, delegate.createImportNamespaceSpecifier(id));\n    }\n\n    function parseImportDeclaration() {\n        var specifiers, src, marker = markerCreate(), importKind = 'value',\n            token2;\n\n        expectKeyword('import');\n\n        if (matchContextualKeyword('type')) {\n            token2 = lookahead2();\n            if ((token2.type === Token.Identifier && token2.value !== 'from') ||\n                    (token2.type === Token.Punctuator &&\n                        (token2.value === '{' || token2.value === '*'))) {\n                importKind = 'type';\n                lex();\n            }\n        } else if (matchKeyword('typeof')) {\n            importKind = 'typeof';\n            lex();\n        }\n\n        specifiers = [];\n\n        if (lookahead.type === Token.StringLiteral) {\n            // covers:\n            // import \"foo\";\n            src = parseModuleSpecifier();\n            consumeSemicolon();\n            return markerApply(marker, delegate.createImportDeclaration(specifiers, src, importKind));\n        }\n\n        if (!matchKeyword('default') && isIdentifierName(lookahead)) {\n            // covers:\n            // import foo\n            // import foo, ...\n            specifiers.push(parseImportDefaultSpecifier());\n            if (match(',')) {\n                lex();\n            }\n        }\n        if (match('*')) {\n            // covers:\n            // import foo, * as foo\n            // import * as foo\n            specifiers.push(parseImportNamespaceSpecifier());\n        } else if (match('{')) {\n            // covers:\n            // import foo, {bar}\n            // import {bar}\n            specifiers = specifiers.concat(parseNamedImports());\n        }\n\n        if (!matchContextualKeyword('from')) {\n            throwError({}, lookahead.value ?\n                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n        }\n        lex();\n        src = parseModuleSpecifier();\n        consumeSemicolon();\n\n        return markerApply(marker, delegate.createImportDeclaration(specifiers, src, importKind));\n    }\n\n    // 12.3 Empty Statement\n\n    function parseEmptyStatement() {\n        var marker = markerCreate();\n        expect(';');\n        return markerApply(marker, delegate.createEmptyStatement());\n    }\n\n    // 12.4 Expression Statement\n\n    function parseExpressionStatement() {\n        var marker = markerCreate(), expr = parseExpression();\n        consumeSemicolon();\n        return markerApply(marker, delegate.createExpressionStatement(expr));\n    }\n\n    // 12.5 If statement\n\n    function parseIfStatement() {\n        var test, consequent, alternate, marker = markerCreate();\n\n        expectKeyword('if');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        consequent = parseStatement();\n\n        if (matchKeyword('else')) {\n            lex();\n            alternate = parseStatement();\n        } else {\n            alternate = null;\n        }\n\n        return markerApply(marker, delegate.createIfStatement(test, consequent, alternate));\n    }\n\n    // 12.6 Iteration Statements\n\n    function parseDoWhileStatement() {\n        var body, test, oldInIteration, marker = markerCreate();\n\n        expectKeyword('do');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        expectKeyword('while');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        if (match(';')) {\n            lex();\n        }\n\n        return markerApply(marker, delegate.createDoWhileStatement(body, test));\n    }\n\n    function parseWhileStatement() {\n        var test, body, oldInIteration, marker = markerCreate();\n\n        expectKeyword('while');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        return markerApply(marker, delegate.createWhileStatement(test, body));\n    }\n\n    function parseForVariableDeclaration() {\n        var marker = markerCreate(),\n            token = lex(),\n            declarations = parseVariableDeclarationList();\n\n        return markerApply(marker, delegate.createVariableDeclaration(declarations, token.value));\n    }\n\n    function parseForStatement(opts) {\n        var init, test, update, left, right, body, operator, oldInIteration,\n            marker = markerCreate();\n        init = test = update = null;\n        expectKeyword('for');\n\n        // http://wiki.ecmascript.org/doku.php?id=proposals:iterators_and_generators&s=each\n        if (matchContextualKeyword('each')) {\n            throwError({}, Messages.EachNotAllowed);\n        }\n\n        expect('(');\n\n        if (match(';')) {\n            lex();\n        } else {\n            if (matchKeyword('var') || matchKeyword('let') || matchKeyword('const')) {\n                state.allowIn = false;\n                init = parseForVariableDeclaration();\n                state.allowIn = true;\n\n                if (init.declarations.length === 1) {\n                    if (matchKeyword('in') || matchContextualKeyword('of')) {\n                        operator = lookahead;\n                        if (!((operator.value === 'in' || init.kind !== 'var') && init.declarations[0].init)) {\n                            lex();\n                            left = init;\n                            right = parseExpression();\n                            init = null;\n                        }\n                    }\n                }\n            } else {\n                state.allowIn = false;\n                init = parseExpression();\n                state.allowIn = true;\n\n                if (matchContextualKeyword('of')) {\n                    operator = lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                } else if (matchKeyword('in')) {\n                    // LeftHandSideExpression\n                    if (!isAssignableLeftHandSide(init)) {\n                        throwError({}, Messages.InvalidLHSInForIn);\n                    }\n                    operator = lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                }\n            }\n\n            if (typeof left === 'undefined') {\n                expect(';');\n            }\n        }\n\n        if (typeof left === 'undefined') {\n\n            if (!match(';')) {\n                test = parseExpression();\n            }\n            expect(';');\n\n            if (!match(')')) {\n                update = parseExpression();\n            }\n        }\n\n        expect(')');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        if (!(opts !== undefined && opts.ignoreBody)) {\n            body = parseStatement();\n        }\n\n        state.inIteration = oldInIteration;\n\n        if (typeof left === 'undefined') {\n            return markerApply(marker, delegate.createForStatement(init, test, update, body));\n        }\n\n        if (operator.value === 'in') {\n            return markerApply(marker, delegate.createForInStatement(left, right, body));\n        }\n        return markerApply(marker, delegate.createForOfStatement(left, right, body));\n    }\n\n    // 12.7 The continue statement\n\n    function parseContinueStatement() {\n        var label = null, marker = markerCreate();\n\n        expectKeyword('continue');\n\n        // Optimize the most common form: 'continue;'.\n        if (source.charCodeAt(index) === 59) {\n            lex();\n\n            if (!state.inIteration) {\n                throwError({}, Messages.IllegalContinue);\n            }\n\n            return markerApply(marker, delegate.createContinueStatement(null));\n        }\n\n        if (peekLineTerminator()) {\n            if (!state.inIteration) {\n                throwError({}, Messages.IllegalContinue);\n            }\n\n            return markerApply(marker, delegate.createContinueStatement(null));\n        }\n\n        if (lookahead.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n\n            if (!state.labelSet.has(label.name)) {\n                throwError({}, Messages.UnknownLabel, label.name);\n            }\n        }\n\n        consumeSemicolon();\n\n        if (label === null && !state.inIteration) {\n            throwError({}, Messages.IllegalContinue);\n        }\n\n        return markerApply(marker, delegate.createContinueStatement(label));\n    }\n\n    // 12.8 The break statement\n\n    function parseBreakStatement() {\n        var label = null, marker = markerCreate();\n\n        expectKeyword('break');\n\n        // Catch the very common case first: immediately a semicolon (char #59).\n        if (source.charCodeAt(index) === 59) {\n            lex();\n\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError({}, Messages.IllegalBreak);\n            }\n\n            return markerApply(marker, delegate.createBreakStatement(null));\n        }\n\n        if (peekLineTerminator()) {\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError({}, Messages.IllegalBreak);\n            }\n\n            return markerApply(marker, delegate.createBreakStatement(null));\n        }\n\n        if (lookahead.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n\n            if (!state.labelSet.has(label.name)) {\n                throwError({}, Messages.UnknownLabel, label.name);\n            }\n        }\n\n        consumeSemicolon();\n\n        if (label === null && !(state.inIteration || state.inSwitch)) {\n            throwError({}, Messages.IllegalBreak);\n        }\n\n        return markerApply(marker, delegate.createBreakStatement(label));\n    }\n\n    // 12.9 The return statement\n\n    function parseReturnStatement() {\n        var argument = null, marker = markerCreate();\n\n        expectKeyword('return');\n\n        if (!state.inFunctionBody) {\n            throwErrorTolerant({}, Messages.IllegalReturn);\n        }\n\n        // 'return' followed by a space and an identifier is very common.\n        if (source.charCodeAt(index) === 32) {\n            if (isIdentifierStart(source.charCodeAt(index + 1))) {\n                argument = parseExpression();\n                consumeSemicolon();\n                return markerApply(marker, delegate.createReturnStatement(argument));\n            }\n        }\n\n        if (peekLineTerminator()) {\n            return markerApply(marker, delegate.createReturnStatement(null));\n        }\n\n        if (!match(';')) {\n            if (!match('}') && lookahead.type !== Token.EOF) {\n                argument = parseExpression();\n            }\n        }\n\n        consumeSemicolon();\n\n        return markerApply(marker, delegate.createReturnStatement(argument));\n    }\n\n    // 12.10 The with statement\n\n    function parseWithStatement() {\n        var object, body, marker = markerCreate();\n\n        if (strict) {\n            throwErrorTolerant({}, Messages.StrictModeWith);\n        }\n\n        expectKeyword('with');\n\n        expect('(');\n\n        object = parseExpression();\n\n        expect(')');\n\n        body = parseStatement();\n\n        return markerApply(marker, delegate.createWithStatement(object, body));\n    }\n\n    // 12.10 The swith statement\n\n    function parseSwitchCase() {\n        var test,\n            consequent = [],\n            sourceElement,\n            marker = markerCreate();\n\n        if (matchKeyword('default')) {\n            lex();\n            test = null;\n        } else {\n            expectKeyword('case');\n            test = parseExpression();\n        }\n        expect(':');\n\n        while (index < length) {\n            if (match('}') || matchKeyword('default') || matchKeyword('case')) {\n                break;\n            }\n            sourceElement = parseSourceElement();\n            if (typeof sourceElement === 'undefined') {\n                break;\n            }\n            consequent.push(sourceElement);\n        }\n\n        return markerApply(marker, delegate.createSwitchCase(test, consequent));\n    }\n\n    function parseSwitchStatement() {\n        var discriminant, cases, clause, oldInSwitch, defaultFound, marker = markerCreate();\n\n        expectKeyword('switch');\n\n        expect('(');\n\n        discriminant = parseExpression();\n\n        expect(')');\n\n        expect('{');\n\n        cases = [];\n\n        if (match('}')) {\n            lex();\n            return markerApply(marker, delegate.createSwitchStatement(discriminant, cases));\n        }\n\n        oldInSwitch = state.inSwitch;\n        state.inSwitch = true;\n        defaultFound = false;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            clause = parseSwitchCase();\n            if (clause.test === null) {\n                if (defaultFound) {\n                    throwError({}, Messages.MultipleDefaultsInSwitch);\n                }\n                defaultFound = true;\n            }\n            cases.push(clause);\n        }\n\n        state.inSwitch = oldInSwitch;\n\n        expect('}');\n\n        return markerApply(marker, delegate.createSwitchStatement(discriminant, cases));\n    }\n\n    // 12.13 The throw statement\n\n    function parseThrowStatement() {\n        var argument, marker = markerCreate();\n\n        expectKeyword('throw');\n\n        if (peekLineTerminator()) {\n            throwError({}, Messages.NewlineAfterThrow);\n        }\n\n        argument = parseExpression();\n\n        consumeSemicolon();\n\n        return markerApply(marker, delegate.createThrowStatement(argument));\n    }\n\n    // 12.14 The try statement\n\n    function parseCatchClause() {\n        var param, body, marker = markerCreate();\n\n        expectKeyword('catch');\n\n        expect('(');\n        if (match(')')) {\n            throwUnexpected(lookahead);\n        }\n\n        param = parseExpression();\n        // 12.14.1\n        if (strict && param.type === Syntax.Identifier && isRestrictedWord(param.name)) {\n            throwErrorTolerant({}, Messages.StrictCatchVariable);\n        }\n\n        expect(')');\n        body = parseBlock();\n        return markerApply(marker, delegate.createCatchClause(param, body));\n    }\n\n    function parseTryStatement() {\n        var block, handlers = [], finalizer = null, marker = markerCreate();\n\n        expectKeyword('try');\n\n        block = parseBlock();\n\n        if (matchKeyword('catch')) {\n            handlers.push(parseCatchClause());\n        }\n\n        if (matchKeyword('finally')) {\n            lex();\n            finalizer = parseBlock();\n        }\n\n        if (handlers.length === 0 && !finalizer) {\n            throwError({}, Messages.NoCatchOrFinally);\n        }\n\n        return markerApply(marker, delegate.createTryStatement(block, [], handlers, finalizer));\n    }\n\n    // 12.15 The debugger statement\n\n    function parseDebuggerStatement() {\n        var marker = markerCreate();\n        expectKeyword('debugger');\n\n        consumeSemicolon();\n\n        return markerApply(marker, delegate.createDebuggerStatement());\n    }\n\n    // 12 Statements\n\n    function parseStatement() {\n        var type = lookahead.type,\n            marker,\n            expr,\n            labeledBody;\n\n        if (type === Token.EOF) {\n            throwUnexpected(lookahead);\n        }\n\n        if (type === Token.Punctuator) {\n            switch (lookahead.value) {\n            case ';':\n                return parseEmptyStatement();\n            case '{':\n                return parseBlock();\n            case '(':\n                return parseExpressionStatement();\n            default:\n                break;\n            }\n        }\n\n        if (type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'break':\n                return parseBreakStatement();\n            case 'continue':\n                return parseContinueStatement();\n            case 'debugger':\n                return parseDebuggerStatement();\n            case 'do':\n                return parseDoWhileStatement();\n            case 'for':\n                return parseForStatement();\n            case 'function':\n                return parseFunctionDeclaration();\n            case 'class':\n                return parseClassDeclaration();\n            case 'if':\n                return parseIfStatement();\n            case 'return':\n                return parseReturnStatement();\n            case 'switch':\n                return parseSwitchStatement();\n            case 'throw':\n                return parseThrowStatement();\n            case 'try':\n                return parseTryStatement();\n            case 'var':\n                return parseVariableStatement();\n            case 'while':\n                return parseWhileStatement();\n            case 'with':\n                return parseWithStatement();\n            default:\n                break;\n            }\n        }\n\n        if (matchAsyncFuncExprOrDecl()) {\n            return parseFunctionDeclaration();\n        }\n\n        marker = markerCreate();\n        expr = parseExpression();\n\n        // 12.12 Labelled Statements\n        if ((expr.type === Syntax.Identifier) && match(':')) {\n            lex();\n\n            if (state.labelSet.has(expr.name)) {\n                throwError({}, Messages.Redeclaration, 'Label', expr.name);\n            }\n\n            state.labelSet.set(expr.name, true);\n            labeledBody = parseStatement();\n            state.labelSet.delete(expr.name);\n            return markerApply(marker, delegate.createLabeledStatement(expr, labeledBody));\n        }\n\n        consumeSemicolon();\n\n        return markerApply(marker, delegate.createExpressionStatement(expr));\n    }\n\n    // 13 Function Definition\n\n    function parseConciseBody() {\n        if (match('{')) {\n            return parseFunctionSourceElements();\n        }\n        return parseAssignmentExpression();\n    }\n\n    function parseFunctionSourceElements() {\n        var sourceElement, sourceElements = [], token, directive, firstRestricted,\n            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, oldParenthesizedCount,\n            marker = markerCreate();\n\n        expect('{');\n\n        while (index < length) {\n            if (lookahead.type !== Token.StringLiteral) {\n                break;\n            }\n            token = lookahead;\n\n            sourceElement = parseSourceElement();\n            sourceElements.push(sourceElement);\n            if (sourceElement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = source.slice(token.range[0] + 1, token.range[1] - 1);\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n\n        oldLabelSet = state.labelSet;\n        oldInIteration = state.inIteration;\n        oldInSwitch = state.inSwitch;\n        oldInFunctionBody = state.inFunctionBody;\n        oldParenthesizedCount = state.parenthesizedCount;\n\n        state.labelSet = new StringMap();\n        state.inIteration = false;\n        state.inSwitch = false;\n        state.inFunctionBody = true;\n        state.parenthesizedCount = 0;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            sourceElement = parseSourceElement();\n            if (typeof sourceElement === 'undefined') {\n                break;\n            }\n            sourceElements.push(sourceElement);\n        }\n\n        expect('}');\n\n        state.labelSet = oldLabelSet;\n        state.inIteration = oldInIteration;\n        state.inSwitch = oldInSwitch;\n        state.inFunctionBody = oldInFunctionBody;\n        state.parenthesizedCount = oldParenthesizedCount;\n\n        return markerApply(marker, delegate.createBlockStatement(sourceElements));\n    }\n\n    function validateParam(options, param, name) {\n        if (strict) {\n            if (isRestrictedWord(name)) {\n                options.stricted = param;\n                options.message = Messages.StrictParamName;\n            }\n            if (options.paramSet.has(name)) {\n                options.stricted = param;\n                options.message = Messages.StrictParamDupe;\n            }\n        } else if (!options.firstRestricted) {\n            if (isRestrictedWord(name)) {\n                options.firstRestricted = param;\n                options.message = Messages.StrictParamName;\n            } else if (isStrictModeReservedWord(name)) {\n                options.firstRestricted = param;\n                options.message = Messages.StrictReservedWord;\n            } else if (options.paramSet.has(name)) {\n                options.firstRestricted = param;\n                options.message = Messages.StrictParamDupe;\n            }\n        }\n        options.paramSet.set(name, true);\n    }\n\n    function parseParam(options) {\n        var marker, token, rest, param, def;\n\n        token = lookahead;\n        if (token.value === '...') {\n            token = lex();\n            rest = true;\n        }\n\n        if (match('[')) {\n            marker = markerCreate();\n            param = parseArrayInitialiser();\n            reinterpretAsDestructuredParameter(options, param);\n            if (match(':')) {\n                param.typeAnnotation = parseTypeAnnotation();\n                markerApply(marker, param);\n            }\n        } else if (match('{')) {\n            marker = markerCreate();\n            if (rest) {\n                throwError({}, Messages.ObjectPatternAsRestParameter);\n            }\n            param = parseObjectInitialiser();\n            reinterpretAsDestructuredParameter(options, param);\n            if (match(':')) {\n                param.typeAnnotation = parseTypeAnnotation();\n                markerApply(marker, param);\n            }\n        } else {\n            param =\n                rest\n                ? parseTypeAnnotatableIdentifier(\n                    false, /* requireTypeAnnotation */\n                    false /* canBeOptionalParam */\n                )\n                : parseTypeAnnotatableIdentifier(\n                    false, /* requireTypeAnnotation */\n                    true /* canBeOptionalParam */\n                );\n\n            validateParam(options, token, token.value);\n        }\n\n        if (match('=')) {\n            if (rest) {\n                throwErrorTolerant(lookahead, Messages.DefaultRestParameter);\n            }\n            lex();\n            def = parseAssignmentExpression();\n            ++options.defaultCount;\n        }\n\n        if (rest) {\n            if (!match(')')) {\n                throwError({}, Messages.ParameterAfterRestParameter);\n            }\n            options.rest = param;\n            return false;\n        }\n\n        options.params.push(param);\n        options.defaults.push(def);\n        return !match(')');\n    }\n\n    function parseParams(firstRestricted) {\n        var options, marker = markerCreate();\n\n        options = {\n            params: [],\n            defaultCount: 0,\n            defaults: [],\n            rest: null,\n            firstRestricted: firstRestricted\n        };\n\n        expect('(');\n\n        if (!match(')')) {\n            options.paramSet = new StringMap();\n            while (index < length) {\n                if (!parseParam(options)) {\n                    break;\n                }\n                expect(',');\n                if (!options.rest && match(')')) {\n                    break;\n                }\n            }\n        }\n\n        expect(')');\n\n        if (options.defaultCount === 0) {\n            options.defaults = [];\n        }\n\n        if (match(':')) {\n            options.returnType = parseTypeAnnotation();\n        }\n\n        return markerApply(marker, options);\n    }\n\n    function parseFunctionDeclaration() {\n        var id, body, token, tmp, firstRestricted, message, generator, isAsync,\n            previousStrict, previousYieldAllowed, previousAwaitAllowed,\n            marker = markerCreate(), typeParameters;\n\n        isAsync = false;\n        if (matchAsync()) {\n            lex();\n            isAsync = true;\n        }\n\n        expectKeyword('function');\n\n        generator = false;\n        if (match('*')) {\n            lex();\n            generator = true;\n        }\n\n        token = lookahead;\n\n        id = parseVariableIdentifier();\n\n        if (match('<')) {\n            typeParameters = parseTypeParameterDeclaration();\n        }\n\n        if (strict) {\n            if (isRestrictedWord(token.value)) {\n                throwErrorTolerant(token, Messages.StrictFunctionName);\n            }\n        } else {\n            if (isRestrictedWord(token.value)) {\n                firstRestricted = token;\n                message = Messages.StrictFunctionName;\n            } else if (isStrictModeReservedWord(token.value)) {\n                firstRestricted = token;\n                message = Messages.StrictReservedWord;\n            }\n        }\n\n        tmp = parseParams(firstRestricted);\n        firstRestricted = tmp.firstRestricted;\n        if (tmp.message) {\n            message = tmp.message;\n        }\n\n        previousStrict = strict;\n        previousYieldAllowed = state.yieldAllowed;\n        state.yieldAllowed = generator;\n        previousAwaitAllowed = state.awaitAllowed;\n        state.awaitAllowed = isAsync;\n\n        body = parseFunctionSourceElements();\n\n        if (strict && firstRestricted) {\n            throwError(firstRestricted, message);\n        }\n        if (strict && tmp.stricted) {\n            throwErrorTolerant(tmp.stricted, message);\n        }\n        strict = previousStrict;\n        state.yieldAllowed = previousYieldAllowed;\n        state.awaitAllowed = previousAwaitAllowed;\n\n        return markerApply(\n            marker,\n            delegate.createFunctionDeclaration(\n                id,\n                tmp.params,\n                tmp.defaults,\n                body,\n                tmp.rest,\n                generator,\n                false,\n                isAsync,\n                tmp.returnType,\n                typeParameters\n            )\n        );\n    }\n\n    function parseFunctionExpression() {\n        var token, id = null, firstRestricted, message, tmp, body, generator, isAsync,\n            previousStrict, previousYieldAllowed, previousAwaitAllowed,\n            marker = markerCreate(), typeParameters;\n\n        isAsync = false;\n        if (matchAsync()) {\n            lex();\n            isAsync = true;\n        }\n\n        expectKeyword('function');\n\n        generator = false;\n\n        if (match('*')) {\n            lex();\n            generator = true;\n        }\n\n        if (!match('(')) {\n            if (!match('<')) {\n                token = lookahead;\n                id = parseVariableIdentifier();\n\n                if (strict) {\n                    if (isRestrictedWord(token.value)) {\n                        throwErrorTolerant(token, Messages.StrictFunctionName);\n                    }\n                } else {\n                    if (isRestrictedWord(token.value)) {\n                        firstRestricted = token;\n                        message = Messages.StrictFunctionName;\n                    } else if (isStrictModeReservedWord(token.value)) {\n                        firstRestricted = token;\n                        message = Messages.StrictReservedWord;\n                    }\n                }\n            }\n\n            if (match('<')) {\n                typeParameters = parseTypeParameterDeclaration();\n            }\n        }\n\n        tmp = parseParams(firstRestricted);\n        firstRestricted = tmp.firstRestricted;\n        if (tmp.message) {\n            message = tmp.message;\n        }\n\n        previousStrict = strict;\n        previousYieldAllowed = state.yieldAllowed;\n        state.yieldAllowed = generator;\n        previousAwaitAllowed = state.awaitAllowed;\n        state.awaitAllowed = isAsync;\n\n        body = parseFunctionSourceElements();\n\n        if (strict && firstRestricted) {\n            throwError(firstRestricted, message);\n        }\n        if (strict && tmp.stricted) {\n            throwErrorTolerant(tmp.stricted, message);\n        }\n        strict = previousStrict;\n        state.yieldAllowed = previousYieldAllowed;\n        state.awaitAllowed = previousAwaitAllowed;\n\n        return markerApply(\n            marker,\n            delegate.createFunctionExpression(\n                id,\n                tmp.params,\n                tmp.defaults,\n                body,\n                tmp.rest,\n                generator,\n                false,\n                isAsync,\n                tmp.returnType,\n                typeParameters\n            )\n        );\n    }\n\n    function parseYieldExpression() {\n        var delegateFlag, expr, marker = markerCreate();\n\n        expectKeyword('yield', !strict);\n\n        delegateFlag = false;\n        if (match('*')) {\n            lex();\n            delegateFlag = true;\n        }\n\n        expr = parseAssignmentExpression();\n\n        return markerApply(marker, delegate.createYieldExpression(expr, delegateFlag));\n    }\n\n    function parseAwaitExpression() {\n        var expr, marker = markerCreate();\n        expectContextualKeyword('await');\n        expr = parseAssignmentExpression();\n        return markerApply(marker, delegate.createAwaitExpression(expr));\n    }\n\n    // 14 Functions and classes\n\n    // 14.1 Functions is defined above (13 in ES5)\n    // 14.2 Arrow Functions Definitions is defined in (7.3 assignments)\n\n    // 14.3 Method Definitions\n    // 14.3.7\n    function specialMethod(methodDefinition) {\n        return methodDefinition.kind === 'get' ||\n               methodDefinition.kind === 'set' ||\n               methodDefinition.value.generator;\n    }\n\n    function parseMethodDefinition(key, isStatic, generator, computed) {\n        var token, param, propType,\n            isAsync, typeParameters, tokenValue, returnType;\n\n        propType = isStatic ? ClassPropertyType.static : ClassPropertyType.prototype;\n\n        if (generator) {\n            return delegate.createMethodDefinition(\n                propType,\n                '',\n                key,\n                parsePropertyMethodFunction({ generator: true }),\n                computed\n            );\n        }\n\n        tokenValue = key.type === 'Identifier' && key.name;\n\n        if (tokenValue === 'get' && !match('(')) {\n            key = parseObjectPropertyKey();\n\n            expect('(');\n            expect(')');\n            if (match(':')) {\n                returnType = parseTypeAnnotation();\n            }\n            return delegate.createMethodDefinition(\n                propType,\n                'get',\n                key,\n                parsePropertyFunction({ generator: false, returnType: returnType }),\n                computed\n            );\n        }\n        if (tokenValue === 'set' && !match('(')) {\n            key = parseObjectPropertyKey();\n\n            expect('(');\n            token = lookahead;\n            param = [ parseTypeAnnotatableIdentifier() ];\n            expect(')');\n            if (match(':')) {\n                returnType = parseTypeAnnotation();\n            }\n            return delegate.createMethodDefinition(\n                propType,\n                'set',\n                key,\n                parsePropertyFunction({\n                    params: param,\n                    generator: false,\n                    name: token,\n                    returnType: returnType\n                }),\n                computed\n            );\n        }\n\n        if (match('<')) {\n            typeParameters = parseTypeParameterDeclaration();\n        }\n\n        isAsync = tokenValue === 'async' && !match('(');\n        if (isAsync) {\n            key = parseObjectPropertyKey();\n        }\n\n        return delegate.createMethodDefinition(\n            propType,\n            '',\n            key,\n            parsePropertyMethodFunction({\n                generator: false,\n                async: isAsync,\n                typeParameters: typeParameters\n            }),\n            computed\n        );\n    }\n\n    function parseClassProperty(key, computed, isStatic) {\n        var typeAnnotation;\n\n        typeAnnotation = parseTypeAnnotation();\n        expect(';');\n\n        return delegate.createClassProperty(\n            key,\n            typeAnnotation,\n            computed,\n            isStatic\n        );\n    }\n\n    function parseClassElement() {\n        var computed = false, generator = false, key, marker = markerCreate(),\n            isStatic = false, possiblyOpenBracketToken;\n        if (match(';')) {\n            lex();\n            return undefined;\n        }\n\n        if (lookahead.value === 'static') {\n            lex();\n            isStatic = true;\n        }\n\n        if (match('*')) {\n            lex();\n            generator = true;\n        }\n\n        possiblyOpenBracketToken = lookahead;\n        if (matchContextualKeyword('get') || matchContextualKeyword('set')) {\n            possiblyOpenBracketToken = lookahead2();\n        }\n\n        if (possiblyOpenBracketToken.type === Token.Punctuator\n                && possiblyOpenBracketToken.value === '[') {\n            computed = true;\n        }\n\n        key = parseObjectPropertyKey();\n\n        if (!generator && lookahead.value === ':') {\n            return markerApply(marker, parseClassProperty(key, computed, isStatic));\n        }\n\n        return markerApply(marker, parseMethodDefinition(\n            key,\n            isStatic,\n            generator,\n            computed\n        ));\n    }\n\n    function parseClassBody() {\n        var classElement, classElements = [], existingProps = {},\n            marker = markerCreate(), propName, propType;\n\n        existingProps[ClassPropertyType.static] = new StringMap();\n        existingProps[ClassPropertyType.prototype] = new StringMap();\n\n        expect('{');\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            classElement = parseClassElement(existingProps);\n\n            if (typeof classElement !== 'undefined') {\n                classElements.push(classElement);\n\n                propName = !classElement.computed && getFieldName(classElement.key);\n                if (propName !== false) {\n                    propType = classElement.static ?\n                                ClassPropertyType.static :\n                                ClassPropertyType.prototype;\n\n                    if (classElement.type === Syntax.MethodDefinition) {\n                        if (propName === 'constructor' && !classElement.static) {\n                            if (specialMethod(classElement)) {\n                                throwError(classElement, Messages.IllegalClassConstructorProperty);\n                            }\n                            if (existingProps[ClassPropertyType.prototype].has('constructor')) {\n                                throwError(classElement.key, Messages.IllegalDuplicateClassProperty);\n                            }\n                        }\n                        existingProps[propType].set(propName, true);\n                    }\n                }\n            }\n        }\n\n        expect('}');\n\n        return markerApply(marker, delegate.createClassBody(classElements));\n    }\n\n    function parseClassImplements() {\n        var id, implemented = [], marker, typeParameters;\n        if (strict) {\n            expectKeyword('implements');\n        } else {\n            expectContextualKeyword('implements');\n        }\n        while (index < length) {\n            marker = markerCreate();\n            id = parseVariableIdentifier();\n            if (match('<')) {\n                typeParameters = parseTypeParameterInstantiation();\n            } else {\n                typeParameters = null;\n            }\n            implemented.push(markerApply(marker, delegate.createClassImplements(\n                id,\n                typeParameters\n            )));\n            if (!match(',')) {\n                break;\n            }\n            expect(',');\n        }\n        return implemented;\n    }\n\n    function parseClassExpression() {\n        var id, implemented, previousYieldAllowed, superClass = null,\n            superTypeParameters, marker = markerCreate(), typeParameters,\n            matchImplements;\n\n        expectKeyword('class');\n\n        matchImplements =\n                strict\n                ? matchKeyword('implements')\n                : matchContextualKeyword('implements');\n\n        if (!matchKeyword('extends') && !matchImplements && !match('{')) {\n            id = parseVariableIdentifier();\n        }\n\n        if (match('<')) {\n            typeParameters = parseTypeParameterDeclaration();\n        }\n\n        if (matchKeyword('extends')) {\n            expectKeyword('extends');\n            previousYieldAllowed = state.yieldAllowed;\n            state.yieldAllowed = false;\n            superClass = parseLeftHandSideExpressionAllowCall();\n            if (match('<')) {\n                superTypeParameters = parseTypeParameterInstantiation();\n            }\n            state.yieldAllowed = previousYieldAllowed;\n        }\n\n        if (strict ? matchKeyword('implements') : matchContextualKeyword('implements')) {\n            implemented = parseClassImplements();\n        }\n\n        return markerApply(marker, delegate.createClassExpression(\n            id,\n            superClass,\n            parseClassBody(),\n            typeParameters,\n            superTypeParameters,\n            implemented\n        ));\n    }\n\n    function parseClassDeclaration() {\n        var id, implemented, previousYieldAllowed, superClass = null,\n            superTypeParameters, marker = markerCreate(), typeParameters;\n\n        expectKeyword('class');\n\n        id = parseVariableIdentifier();\n\n        if (match('<')) {\n            typeParameters = parseTypeParameterDeclaration();\n        }\n\n        if (matchKeyword('extends')) {\n            expectKeyword('extends');\n            previousYieldAllowed = state.yieldAllowed;\n            state.yieldAllowed = false;\n            superClass = parseLeftHandSideExpressionAllowCall();\n            if (match('<')) {\n                superTypeParameters = parseTypeParameterInstantiation();\n            }\n            state.yieldAllowed = previousYieldAllowed;\n        }\n\n        if (strict ? matchKeyword('implements') : matchContextualKeyword('implements')) {\n            implemented = parseClassImplements();\n        }\n\n        return markerApply(marker, delegate.createClassDeclaration(\n            id,\n            superClass,\n            parseClassBody(),\n            typeParameters,\n            superTypeParameters,\n            implemented\n        ));\n    }\n\n    // 15 Program\n\n    function parseSourceElement() {\n        var token;\n        if (lookahead.type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'const':\n            case 'let':\n                return parseConstLetDeclaration(lookahead.value);\n            case 'function':\n                return parseFunctionDeclaration();\n            case 'export':\n                throwErrorTolerant({}, Messages.IllegalExportDeclaration);\n                return parseExportDeclaration();\n            case 'import':\n                throwErrorTolerant({}, Messages.IllegalImportDeclaration);\n                return parseImportDeclaration();\n            case 'interface':\n                if (lookahead2().type === Token.Identifier) {\n                    return parseInterface();\n                }\n                return parseStatement();\n            default:\n                return parseStatement();\n            }\n        }\n\n        if (matchContextualKeyword('type')\n                && lookahead2().type === Token.Identifier) {\n            return parseTypeAlias();\n        }\n\n        if (matchContextualKeyword('interface')\n                && lookahead2().type === Token.Identifier) {\n            return parseInterface();\n        }\n\n        if (matchContextualKeyword('declare')) {\n            token = lookahead2();\n            if (token.type === Token.Keyword) {\n                switch (token.value) {\n                case 'class':\n                    return parseDeclareClass();\n                case 'function':\n                    return parseDeclareFunction();\n                case 'var':\n                    return parseDeclareVariable();\n                }\n            } else if (token.type === Token.Identifier\n                    && token.value === 'module') {\n                return parseDeclareModule();\n            }\n        }\n\n        if (lookahead.type !== Token.EOF) {\n            return parseStatement();\n        }\n    }\n\n    function parseProgramElement() {\n        var isModule = extra.sourceType === 'module' || extra.sourceType === 'nonStrictModule';\n\n        if (isModule && lookahead.type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'export':\n                return parseExportDeclaration();\n            case 'import':\n                return parseImportDeclaration();\n            }\n        }\n\n        return parseSourceElement();\n    }\n\n    function parseProgramElements() {\n        var sourceElement, sourceElements = [], token, directive, firstRestricted;\n\n        while (index < length) {\n            token = lookahead;\n            if (token.type !== Token.StringLiteral) {\n                break;\n            }\n\n            sourceElement = parseProgramElement();\n            sourceElements.push(sourceElement);\n            if (sourceElement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = source.slice(token.range[0] + 1, token.range[1] - 1);\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n\n        while (index < length) {\n            sourceElement = parseProgramElement();\n            if (typeof sourceElement === 'undefined') {\n                break;\n            }\n            sourceElements.push(sourceElement);\n        }\n        return sourceElements;\n    }\n\n    function parseProgram() {\n        var body, marker = markerCreate();\n        strict = extra.sourceType === 'module';\n        peek();\n        body = parseProgramElements();\n        return markerApply(marker, delegate.createProgram(body));\n    }\n\n    // 16 JSX\n\n    XHTMLEntities = {\n        quot: '\\u0022',\n        amp: '&',\n        apos: '\\u0027',\n        lt: '<',\n        gt: '>',\n        nbsp: '\\u00A0',\n        iexcl: '\\u00A1',\n        cent: '\\u00A2',\n        pound: '\\u00A3',\n        curren: '\\u00A4',\n        yen: '\\u00A5',\n        brvbar: '\\u00A6',\n        sect: '\\u00A7',\n        uml: '\\u00A8',\n        copy: '\\u00A9',\n        ordf: '\\u00AA',\n        laquo: '\\u00AB',\n        not: '\\u00AC',\n        shy: '\\u00AD',\n        reg: '\\u00AE',\n        macr: '\\u00AF',\n        deg: '\\u00B0',\n        plusmn: '\\u00B1',\n        sup2: '\\u00B2',\n        sup3: '\\u00B3',\n        acute: '\\u00B4',\n        micro: '\\u00B5',\n        para: '\\u00B6',\n        middot: '\\u00B7',\n        cedil: '\\u00B8',\n        sup1: '\\u00B9',\n        ordm: '\\u00BA',\n        raquo: '\\u00BB',\n        frac14: '\\u00BC',\n        frac12: '\\u00BD',\n        frac34: '\\u00BE',\n        iquest: '\\u00BF',\n        Agrave: '\\u00C0',\n        Aacute: '\\u00C1',\n        Acirc: '\\u00C2',\n        Atilde: '\\u00C3',\n        Auml: '\\u00C4',\n        Aring: '\\u00C5',\n        AElig: '\\u00C6',\n        Ccedil: '\\u00C7',\n        Egrave: '\\u00C8',\n        Eacute: '\\u00C9',\n        Ecirc: '\\u00CA',\n        Euml: '\\u00CB',\n        Igrave: '\\u00CC',\n        Iacute: '\\u00CD',\n        Icirc: '\\u00CE',\n        Iuml: '\\u00CF',\n        ETH: '\\u00D0',\n        Ntilde: '\\u00D1',\n        Ograve: '\\u00D2',\n        Oacute: '\\u00D3',\n        Ocirc: '\\u00D4',\n        Otilde: '\\u00D5',\n        Ouml: '\\u00D6',\n        times: '\\u00D7',\n        Oslash: '\\u00D8',\n        Ugrave: '\\u00D9',\n        Uacute: '\\u00DA',\n        Ucirc: '\\u00DB',\n        Uuml: '\\u00DC',\n        Yacute: '\\u00DD',\n        THORN: '\\u00DE',\n        szlig: '\\u00DF',\n        agrave: '\\u00E0',\n        aacute: '\\u00E1',\n        acirc: '\\u00E2',\n        atilde: '\\u00E3',\n        auml: '\\u00E4',\n        aring: '\\u00E5',\n        aelig: '\\u00E6',\n        ccedil: '\\u00E7',\n        egrave: '\\u00E8',\n        eacute: '\\u00E9',\n        ecirc: '\\u00EA',\n        euml: '\\u00EB',\n        igrave: '\\u00EC',\n        iacute: '\\u00ED',\n        icirc: '\\u00EE',\n        iuml: '\\u00EF',\n        eth: '\\u00F0',\n        ntilde: '\\u00F1',\n        ograve: '\\u00F2',\n        oacute: '\\u00F3',\n        ocirc: '\\u00F4',\n        otilde: '\\u00F5',\n        ouml: '\\u00F6',\n        divide: '\\u00F7',\n        oslash: '\\u00F8',\n        ugrave: '\\u00F9',\n        uacute: '\\u00FA',\n        ucirc: '\\u00FB',\n        uuml: '\\u00FC',\n        yacute: '\\u00FD',\n        thorn: '\\u00FE',\n        yuml: '\\u00FF',\n        OElig: '\\u0152',\n        oelig: '\\u0153',\n        Scaron: '\\u0160',\n        scaron: '\\u0161',\n        Yuml: '\\u0178',\n        fnof: '\\u0192',\n        circ: '\\u02C6',\n        tilde: '\\u02DC',\n        Alpha: '\\u0391',\n        Beta: '\\u0392',\n        Gamma: '\\u0393',\n        Delta: '\\u0394',\n        Epsilon: '\\u0395',\n        Zeta: '\\u0396',\n        Eta: '\\u0397',\n        Theta: '\\u0398',\n        Iota: '\\u0399',\n        Kappa: '\\u039A',\n        Lambda: '\\u039B',\n        Mu: '\\u039C',\n        Nu: '\\u039D',\n        Xi: '\\u039E',\n        Omicron: '\\u039F',\n        Pi: '\\u03A0',\n        Rho: '\\u03A1',\n        Sigma: '\\u03A3',\n        Tau: '\\u03A4',\n        Upsilon: '\\u03A5',\n        Phi: '\\u03A6',\n        Chi: '\\u03A7',\n        Psi: '\\u03A8',\n        Omega: '\\u03A9',\n        alpha: '\\u03B1',\n        beta: '\\u03B2',\n        gamma: '\\u03B3',\n        delta: '\\u03B4',\n        epsilon: '\\u03B5',\n        zeta: '\\u03B6',\n        eta: '\\u03B7',\n        theta: '\\u03B8',\n        iota: '\\u03B9',\n        kappa: '\\u03BA',\n        lambda: '\\u03BB',\n        mu: '\\u03BC',\n        nu: '\\u03BD',\n        xi: '\\u03BE',\n        omicron: '\\u03BF',\n        pi: '\\u03C0',\n        rho: '\\u03C1',\n        sigmaf: '\\u03C2',\n        sigma: '\\u03C3',\n        tau: '\\u03C4',\n        upsilon: '\\u03C5',\n        phi: '\\u03C6',\n        chi: '\\u03C7',\n        psi: '\\u03C8',\n        omega: '\\u03C9',\n        thetasym: '\\u03D1',\n        upsih: '\\u03D2',\n        piv: '\\u03D6',\n        ensp: '\\u2002',\n        emsp: '\\u2003',\n        thinsp: '\\u2009',\n        zwnj: '\\u200C',\n        zwj: '\\u200D',\n        lrm: '\\u200E',\n        rlm: '\\u200F',\n        ndash: '\\u2013',\n        mdash: '\\u2014',\n        lsquo: '\\u2018',\n        rsquo: '\\u2019',\n        sbquo: '\\u201A',\n        ldquo: '\\u201C',\n        rdquo: '\\u201D',\n        bdquo: '\\u201E',\n        dagger: '\\u2020',\n        Dagger: '\\u2021',\n        bull: '\\u2022',\n        hellip: '\\u2026',\n        permil: '\\u2030',\n        prime: '\\u2032',\n        Prime: '\\u2033',\n        lsaquo: '\\u2039',\n        rsaquo: '\\u203A',\n        oline: '\\u203E',\n        frasl: '\\u2044',\n        euro: '\\u20AC',\n        image: '\\u2111',\n        weierp: '\\u2118',\n        real: '\\u211C',\n        trade: '\\u2122',\n        alefsym: '\\u2135',\n        larr: '\\u2190',\n        uarr: '\\u2191',\n        rarr: '\\u2192',\n        darr: '\\u2193',\n        harr: '\\u2194',\n        crarr: '\\u21B5',\n        lArr: '\\u21D0',\n        uArr: '\\u21D1',\n        rArr: '\\u21D2',\n        dArr: '\\u21D3',\n        hArr: '\\u21D4',\n        forall: '\\u2200',\n        part: '\\u2202',\n        exist: '\\u2203',\n        empty: '\\u2205',\n        nabla: '\\u2207',\n        isin: '\\u2208',\n        notin: '\\u2209',\n        ni: '\\u220B',\n        prod: '\\u220F',\n        sum: '\\u2211',\n        minus: '\\u2212',\n        lowast: '\\u2217',\n        radic: '\\u221A',\n        prop: '\\u221D',\n        infin: '\\u221E',\n        ang: '\\u2220',\n        and: '\\u2227',\n        or: '\\u2228',\n        cap: '\\u2229',\n        cup: '\\u222A',\n        'int': '\\u222B',\n        there4: '\\u2234',\n        sim: '\\u223C',\n        cong: '\\u2245',\n        asymp: '\\u2248',\n        ne: '\\u2260',\n        equiv: '\\u2261',\n        le: '\\u2264',\n        ge: '\\u2265',\n        sub: '\\u2282',\n        sup: '\\u2283',\n        nsub: '\\u2284',\n        sube: '\\u2286',\n        supe: '\\u2287',\n        oplus: '\\u2295',\n        otimes: '\\u2297',\n        perp: '\\u22A5',\n        sdot: '\\u22C5',\n        lceil: '\\u2308',\n        rceil: '\\u2309',\n        lfloor: '\\u230A',\n        rfloor: '\\u230B',\n        lang: '\\u2329',\n        rang: '\\u232A',\n        loz: '\\u25CA',\n        spades: '\\u2660',\n        clubs: '\\u2663',\n        hearts: '\\u2665',\n        diams: '\\u2666'\n    };\n\n    function getQualifiedJSXName(object) {\n        if (object.type === Syntax.JSXIdentifier) {\n            return object.name;\n        }\n        if (object.type === Syntax.JSXNamespacedName) {\n            return object.namespace.name + ':' + object.name.name;\n        }\n        /* istanbul ignore else */\n        if (object.type === Syntax.JSXMemberExpression) {\n            return (\n                getQualifiedJSXName(object.object) + '.' +\n                getQualifiedJSXName(object.property)\n            );\n        }\n        /* istanbul ignore next */\n        throwUnexpected(object);\n    }\n\n    function isJSXIdentifierStart(ch) {\n        // exclude backslash (\\)\n        return (ch !== 92) && isIdentifierStart(ch);\n    }\n\n    function isJSXIdentifierPart(ch) {\n        // exclude backslash (\\) and add hyphen (-)\n        return (ch !== 92) && (ch === 45 || isIdentifierPart(ch));\n    }\n\n    function scanJSXIdentifier() {\n        var ch, start, value = '';\n\n        start = index;\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (!isJSXIdentifierPart(ch)) {\n                break;\n            }\n            value += source[index++];\n        }\n\n        return {\n            type: Token.JSXIdentifier,\n            value: value,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    function scanJSXEntity() {\n        var ch, str = '', start = index, count = 0, code;\n        ch = source[index];\n        assert(ch === '&', 'Entity must start with an ampersand');\n        index++;\n        while (index < length && count++ < 10) {\n            ch = source[index++];\n            if (ch === ';') {\n                break;\n            }\n            str += ch;\n        }\n\n        // Well-formed entity (ending was found).\n        if (ch === ';') {\n            // Numeric entity.\n            if (str[0] === '#') {\n                if (str[1] === 'x') {\n                    code = +('0' + str.substr(1));\n                } else {\n                    // Removing leading zeros in order to avoid treating as octal in old browsers.\n                    code = +str.substr(1).replace(Regex.LeadingZeros, '');\n                }\n\n                if (!isNaN(code)) {\n                    return String.fromCharCode(code);\n                }\n            /* istanbul ignore else */\n            } else if (XHTMLEntities[str]) {\n                return XHTMLEntities[str];\n            }\n        }\n\n        // Treat non-entity sequences as regular text.\n        index = start + 1;\n        return '&';\n    }\n\n    function scanJSXText(stopChars) {\n        var ch, str = '', start;\n        start = index;\n        while (index < length) {\n            ch = source[index];\n            if (stopChars.indexOf(ch) !== -1) {\n                break;\n            }\n            if (ch === '&') {\n                str += scanJSXEntity();\n            } else {\n                index++;\n                if (ch === '\\r' && source[index] === '\\n') {\n                    str += ch;\n                    ch = source[index];\n                    index++;\n                }\n                if (isLineTerminator(ch.charCodeAt(0))) {\n                    ++lineNumber;\n                    lineStart = index;\n                }\n                str += ch;\n            }\n        }\n        return {\n            type: Token.JSXText,\n            value: str,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    function scanJSXStringLiteral() {\n        var innerToken, quote, start;\n\n        quote = source[index];\n        assert((quote === '\\'' || quote === '\"'),\n            'String literal must starts with a quote');\n\n        start = index;\n        ++index;\n\n        innerToken = scanJSXText([quote]);\n\n        if (quote !== source[index]) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        ++index;\n\n        innerToken.range = [start, index];\n\n        return innerToken;\n    }\n\n    /**\n     * Between JSX opening and closing tags (e.g. <foo>HERE</foo>), anything that\n     * is not another JSX tag and is not an expression wrapped by {} is text.\n     */\n    function advanceJSXChild() {\n        var ch = source.charCodeAt(index);\n\n        // '<' 60, '>' 62, '{' 123, '}' 125\n        if (ch !== 60 && ch !== 62 && ch !== 123 && ch !== 125) {\n            return scanJSXText(['<', '>', '{', '}']);\n        }\n\n        return scanPunctuator();\n    }\n\n    function parseJSXIdentifier() {\n        var token, marker = markerCreate();\n\n        if (lookahead.type !== Token.JSXIdentifier) {\n            throwUnexpected(lookahead);\n        }\n\n        token = lex();\n        return markerApply(marker, delegate.createJSXIdentifier(token.value));\n    }\n\n    function parseJSXNamespacedName() {\n        var namespace, name, marker = markerCreate();\n\n        namespace = parseJSXIdentifier();\n        expect(':');\n        name = parseJSXIdentifier();\n\n        return markerApply(marker, delegate.createJSXNamespacedName(namespace, name));\n    }\n\n    function parseJSXMemberExpression() {\n        var marker = markerCreate(),\n            expr = parseJSXIdentifier();\n\n        while (match('.')) {\n            lex();\n            expr = markerApply(marker, delegate.createJSXMemberExpression(expr, parseJSXIdentifier()));\n        }\n\n        return expr;\n    }\n\n    function parseJSXElementName() {\n        if (lookahead2().value === ':') {\n            return parseJSXNamespacedName();\n        }\n        if (lookahead2().value === '.') {\n            return parseJSXMemberExpression();\n        }\n\n        return parseJSXIdentifier();\n    }\n\n    function parseJSXAttributeName() {\n        if (lookahead2().value === ':') {\n            return parseJSXNamespacedName();\n        }\n\n        return parseJSXIdentifier();\n    }\n\n    function parseJSXAttributeValue() {\n        var value, marker;\n        if (match('{')) {\n            value = parseJSXExpressionContainer();\n            if (value.expression.type === Syntax.JSXEmptyExpression) {\n                throwError(\n                    value,\n                    'JSX attributes must only be assigned a non-empty ' +\n                        'expression'\n                );\n            }\n        } else if (match('<')) {\n            value = parseJSXElement();\n        } else if (lookahead.type === Token.JSXText) {\n            marker = markerCreate();\n            value = markerApply(marker, delegate.createLiteral(lex()));\n        } else {\n            throwError({}, Messages.InvalidJSXAttributeValue);\n        }\n        return value;\n    }\n\n    function parseJSXEmptyExpression() {\n        var ch, marker = markerCreatePreserveWhitespace();\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (ch === 125) {\n                break;\n            } else if (isLineTerminator(ch)) {\n                if (ch === 13 && source.charCodeAt(index + 1) === 10) {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n            }\n            ++index;\n        }\n        return markerApply(marker, delegate.createJSXEmptyExpression());\n    }\n\n    function parseJSXExpressionContainer() {\n        var expression, origInJSXChild, origInJSXTag, marker = markerCreate();\n\n        origInJSXChild = state.inJSXChild;\n        origInJSXTag = state.inJSXTag;\n        state.inJSXChild = false;\n        state.inJSXTag = false;\n\n        expect('{');\n\n        if (match('}')) {\n            expression = parseJSXEmptyExpression();\n        } else {\n            expression = parseExpression();\n        }\n\n        state.inJSXChild = origInJSXChild;\n        state.inJSXTag = origInJSXTag;\n\n        expect('}');\n\n        return markerApply(marker, delegate.createJSXExpressionContainer(expression));\n    }\n\n    function parseJSXSpreadAttribute() {\n        var expression, origInJSXChild, origInJSXTag, marker = markerCreate();\n\n        origInJSXChild = state.inJSXChild;\n        origInJSXTag = state.inJSXTag;\n        state.inJSXChild = false;\n        state.inJSXTag = false;\n\n        expect('{');\n        expect('...');\n\n        expression = parseAssignmentExpression();\n\n        state.inJSXChild = origInJSXChild;\n        state.inJSXTag = origInJSXTag;\n\n        expect('}');\n\n        return markerApply(marker, delegate.createJSXSpreadAttribute(expression));\n    }\n\n    function parseJSXAttribute() {\n        var name, marker;\n\n        if (match('{')) {\n            return parseJSXSpreadAttribute();\n        }\n\n        marker = markerCreate();\n\n        name = parseJSXAttributeName();\n\n        // HTML empty attribute\n        if (match('=')) {\n            lex();\n            return markerApply(marker, delegate.createJSXAttribute(name, parseJSXAttributeValue()));\n        }\n\n        return markerApply(marker, delegate.createJSXAttribute(name));\n    }\n\n    function parseJSXChild() {\n        var token, marker;\n        if (match('{')) {\n            token = parseJSXExpressionContainer();\n        } else if (lookahead.type === Token.JSXText) {\n            marker = markerCreatePreserveWhitespace();\n            token = markerApply(marker, delegate.createLiteral(lex()));\n        } else if (match('<')) {\n            token = parseJSXElement();\n        } else {\n            throwUnexpected(lookahead);\n        }\n        return token;\n    }\n\n    function parseJSXClosingElement() {\n        var name, origInJSXChild, origInJSXTag, marker = markerCreate();\n        origInJSXChild = state.inJSXChild;\n        origInJSXTag = state.inJSXTag;\n        state.inJSXChild = false;\n        state.inJSXTag = true;\n        expect('<');\n        expect('/');\n        name = parseJSXElementName();\n        // Because advance() (called by lex() called by expect()) expects there\n        // to be a valid token after >, it needs to know whether to look for a\n        // standard JS token or an JSX text node\n        state.inJSXChild = origInJSXChild;\n        state.inJSXTag = origInJSXTag;\n        expect('>');\n        return markerApply(marker, delegate.createJSXClosingElement(name));\n    }\n\n    function parseJSXOpeningElement() {\n        var name, attributes = [], selfClosing = false, origInJSXChild, origInJSXTag, marker = markerCreate();\n\n        origInJSXChild = state.inJSXChild;\n        origInJSXTag = state.inJSXTag;\n        state.inJSXChild = false;\n        state.inJSXTag = true;\n\n        expect('<');\n\n        name = parseJSXElementName();\n\n        while (index < length &&\n                lookahead.value !== '/' &&\n                lookahead.value !== '>') {\n            attributes.push(parseJSXAttribute());\n        }\n\n        state.inJSXTag = origInJSXTag;\n\n        if (lookahead.value === '/') {\n            expect('/');\n            // Because advance() (called by lex() called by expect()) expects\n            // there to be a valid token after >, it needs to know whether to\n            // look for a standard JS token or an JSX text node\n            state.inJSXChild = origInJSXChild;\n            expect('>');\n            selfClosing = true;\n        } else {\n            state.inJSXChild = true;\n            expect('>');\n        }\n        return markerApply(marker, delegate.createJSXOpeningElement(name, attributes, selfClosing));\n    }\n\n    function parseJSXElement() {\n        var openingElement, closingElement = null, children = [], origInJSXChild, origInJSXTag, marker = markerCreate();\n\n        origInJSXChild = state.inJSXChild;\n        origInJSXTag = state.inJSXTag;\n        openingElement = parseJSXOpeningElement();\n\n        if (!openingElement.selfClosing) {\n            while (index < length) {\n                state.inJSXChild = false; // Call lookahead2() with inJSXChild = false because </ should not be considered in the child\n                if (lookahead.value === '<' && lookahead2().value === '/') {\n                    break;\n                }\n                state.inJSXChild = true;\n                children.push(parseJSXChild());\n            }\n            state.inJSXChild = origInJSXChild;\n            state.inJSXTag = origInJSXTag;\n            closingElement = parseJSXClosingElement();\n            if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n                throwError({}, Messages.ExpectedJSXClosingTag, getQualifiedJSXName(openingElement.name));\n            }\n        }\n\n        // When (erroneously) writing two adjacent tags like\n        //\n        //     var x = <div>one</div><div>two</div>;\n        //\n        // the default error message is a bit incomprehensible. Since it's\n        // rarely (never?) useful to write a less-than sign after an JSX\n        // element, we disallow it here in the parser in order to provide a\n        // better error message. (In the rare case that the less-than operator\n        // was intended, the left tag can be wrapped in parentheses.)\n        if (!origInJSXChild && match('<')) {\n            throwError(lookahead, Messages.AdjacentJSXElements);\n        }\n\n        return markerApply(marker, delegate.createJSXElement(openingElement, closingElement, children));\n    }\n\n    function parseTypeAlias() {\n        var id, marker = markerCreate(), typeParameters = null, right;\n        expectContextualKeyword('type');\n        id = parseVariableIdentifier();\n        if (match('<')) {\n            typeParameters = parseTypeParameterDeclaration();\n        }\n        expect('=');\n        right = parseType();\n        consumeSemicolon();\n        return markerApply(marker, delegate.createTypeAlias(id, typeParameters, right));\n    }\n\n    function parseInterfaceExtends() {\n        var marker = markerCreate(), id, typeParameters = null;\n\n        id = parseVariableIdentifier();\n        if (match('<')) {\n            typeParameters = parseTypeParameterInstantiation();\n        }\n\n        return markerApply(marker, delegate.createInterfaceExtends(\n            id,\n            typeParameters\n        ));\n    }\n\n    function parseInterfaceish(marker, allowStatic) {\n        var body, bodyMarker, extended = [], id,\n            typeParameters = null;\n\n        id = parseVariableIdentifier();\n        if (match('<')) {\n            typeParameters = parseTypeParameterDeclaration();\n        }\n\n        if (matchKeyword('extends')) {\n            expectKeyword('extends');\n\n            while (index < length) {\n                extended.push(parseInterfaceExtends());\n                if (!match(',')) {\n                    break;\n                }\n                expect(',');\n            }\n        }\n\n        bodyMarker = markerCreate();\n        body = markerApply(bodyMarker, parseObjectType(allowStatic));\n\n        return markerApply(marker, delegate.createInterface(\n            id,\n            typeParameters,\n            body,\n            extended\n        ));\n    }\n\n    function parseInterface() {\n        var marker = markerCreate();\n\n        if (strict) {\n            expectKeyword('interface');\n        } else {\n            expectContextualKeyword('interface');\n        }\n\n        return parseInterfaceish(marker, /* allowStatic */false);\n    }\n\n    function parseDeclareClass() {\n        var marker = markerCreate(), ret;\n        expectContextualKeyword('declare');\n        expectKeyword('class');\n\n        ret = parseInterfaceish(marker, /* allowStatic */true);\n        ret.type = Syntax.DeclareClass;\n        return ret;\n    }\n\n    function parseDeclareFunction() {\n        var id, idMarker,\n            marker = markerCreate(), params, returnType, rest, tmp,\n            typeParameters = null, value, valueMarker;\n\n        expectContextualKeyword('declare');\n        expectKeyword('function');\n        idMarker = markerCreate();\n        id = parseVariableIdentifier();\n\n        valueMarker = markerCreate();\n        if (match('<')) {\n            typeParameters = parseTypeParameterDeclaration();\n        }\n        expect('(');\n        tmp = parseFunctionTypeParams();\n        params = tmp.params;\n        rest = tmp.rest;\n        expect(')');\n\n        expect(':');\n        returnType = parseType();\n\n        value = markerApply(valueMarker, delegate.createFunctionTypeAnnotation(\n            params,\n            returnType,\n            rest,\n            typeParameters\n        ));\n\n        id.typeAnnotation = markerApply(valueMarker, delegate.createTypeAnnotation(\n            value\n        ));\n        markerApply(idMarker, id);\n\n        consumeSemicolon();\n\n        return markerApply(marker, delegate.createDeclareFunction(\n            id\n        ));\n    }\n\n    function parseDeclareVariable() {\n        var id, marker = markerCreate();\n        expectContextualKeyword('declare');\n        expectKeyword('var');\n        id = parseTypeAnnotatableIdentifier();\n\n        consumeSemicolon();\n\n        return markerApply(marker, delegate.createDeclareVariable(\n            id\n        ));\n    }\n\n    function parseDeclareModule() {\n        var body = [], bodyMarker, id, idMarker, marker = markerCreate(), token;\n        expectContextualKeyword('declare');\n        expectContextualKeyword('module');\n\n        if (lookahead.type === Token.StringLiteral) {\n            if (strict && lookahead.octal) {\n                throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);\n            }\n            idMarker = markerCreate();\n            id = markerApply(idMarker, delegate.createLiteral(lex()));\n        } else {\n            id = parseVariableIdentifier();\n        }\n\n        bodyMarker = markerCreate();\n        expect('{');\n        while (index < length && !match('}')) {\n            token = lookahead2();\n            switch (token.value) {\n            case 'class':\n                body.push(parseDeclareClass());\n                break;\n            case 'function':\n                body.push(parseDeclareFunction());\n                break;\n            case 'var':\n                body.push(parseDeclareVariable());\n                break;\n            default:\n                throwUnexpected(lookahead);\n            }\n        }\n        expect('}');\n\n        return markerApply(marker, delegate.createDeclareModule(\n            id,\n            markerApply(bodyMarker, delegate.createBlockStatement(body))\n        ));\n    }\n\n    function collectToken() {\n        var loc, token, range, value, entry;\n\n        /* istanbul ignore else */\n        if (!state.inJSXChild) {\n            skipComment();\n        }\n\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        token = extra.advance();\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        if (token.type !== Token.EOF) {\n            range = [token.range[0], token.range[1]];\n            value = source.slice(token.range[0], token.range[1]);\n            entry = {\n                type: TokenName[token.type],\n                value: value,\n                range: range,\n                loc: loc\n            };\n            if (token.regex) {\n                entry.regex = {\n                    pattern: token.regex.pattern,\n                    flags: token.regex.flags\n                };\n            }\n            extra.tokens.push(entry);\n        }\n\n        return token;\n    }\n\n    function collectRegex() {\n        var pos, loc, regex, token;\n\n        skipComment();\n\n        pos = index;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        regex = extra.scanRegExp();\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        if (!extra.tokenize) {\n            /* istanbul ignore next */\n            // Pop the previous token, which is likely '/' or '/='\n            if (extra.tokens.length > 0) {\n                token = extra.tokens[extra.tokens.length - 1];\n                if (token.range[0] === pos && token.type === 'Punctuator') {\n                    if (token.value === '/' || token.value === '/=') {\n                        extra.tokens.pop();\n                    }\n                }\n            }\n\n            extra.tokens.push({\n                type: 'RegularExpression',\n                value: regex.literal,\n                regex: regex.regex,\n                range: [pos, index],\n                loc: loc\n            });\n        }\n\n        return regex;\n    }\n\n    function filterTokenLocation() {\n        var i, entry, token, tokens = [];\n\n        for (i = 0; i < extra.tokens.length; ++i) {\n            entry = extra.tokens[i];\n            token = {\n                type: entry.type,\n                value: entry.value\n            };\n            if (entry.regex) {\n                token.regex = {\n                    pattern: entry.regex.pattern,\n                    flags: entry.regex.flags\n                };\n            }\n            if (extra.range) {\n                token.range = entry.range;\n            }\n            if (extra.loc) {\n                token.loc = entry.loc;\n            }\n            tokens.push(token);\n        }\n\n        extra.tokens = tokens;\n    }\n\n    function patch() {\n        if (typeof extra.tokens !== 'undefined') {\n            extra.advance = advance;\n            extra.scanRegExp = scanRegExp;\n\n            advance = collectToken;\n            scanRegExp = collectRegex;\n        }\n    }\n\n    function unpatch() {\n        if (typeof extra.scanRegExp === 'function') {\n            advance = extra.advance;\n            scanRegExp = extra.scanRegExp;\n        }\n    }\n\n    // This is used to modify the delegate.\n\n    function extend(object, properties) {\n        var entry, result = {};\n\n        for (entry in object) {\n            /* istanbul ignore else */\n            if (object.hasOwnProperty(entry)) {\n                result[entry] = object[entry];\n            }\n        }\n\n        for (entry in properties) {\n            /* istanbul ignore else */\n            if (properties.hasOwnProperty(entry)) {\n                result[entry] = properties[entry];\n            }\n        }\n\n        return result;\n    }\n\n    function tokenize(code, options) {\n        var toString,\n            token,\n            tokens;\n\n        toString = String;\n        if (typeof code !== 'string' && !(code instanceof String)) {\n            code = toString(code);\n        }\n\n        delegate = SyntaxTreeDelegate;\n        source = code;\n        index = 0;\n        lineNumber = (source.length > 0) ? 1 : 0;\n        lineStart = 0;\n        length = source.length;\n        lookahead = null;\n        state = {\n            allowKeyword: true,\n            allowIn: true,\n            labelSet: new StringMap(),\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false,\n            lastCommentStart: -1,\n            curlyStack: [],\n            curlyLastIndex: 0\n        };\n\n        extra = {};\n\n        // Options matching.\n        options = options || {};\n\n        // Of course we collect tokens here.\n        options.tokens = true;\n        extra.tokens = [];\n        extra.tokenize = true;\n        // The following two fields are necessary to compute the Regex tokens.\n        extra.openParenToken = -1;\n        extra.openCurlyToken = -1;\n\n        extra.range = (typeof options.range === 'boolean') && options.range;\n        extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n        if (typeof options.comment === 'boolean' && options.comment) {\n            extra.comments = [];\n        }\n        if (typeof options.tolerant === 'boolean' && options.tolerant) {\n            extra.errors = [];\n        }\n\n        patch();\n\n        try {\n            peek();\n            if (lookahead.type === Token.EOF) {\n                return extra.tokens;\n            }\n\n            token = lex();\n            while (lookahead.type !== Token.EOF) {\n                try {\n                    token = lex();\n                } catch (lexError) {\n                    token = lookahead;\n                    if (extra.errors) {\n                        extra.errors.push(lexError);\n                        // We have to break on the first error\n                        // to avoid infinite loops.\n                        break;\n                    } else {\n                        throw lexError;\n                    }\n                }\n            }\n\n            filterTokenLocation();\n            tokens = extra.tokens;\n            if (typeof extra.comments !== 'undefined') {\n                tokens.comments = extra.comments;\n            }\n            if (typeof extra.errors !== 'undefined') {\n                tokens.errors = extra.errors;\n            }\n        } catch (e) {\n            throw e;\n        } finally {\n            unpatch();\n            extra = {};\n        }\n        return tokens;\n    }\n\n    function parse(code, options) {\n        var program, toString;\n\n        toString = String;\n        if (typeof code !== 'string' && !(code instanceof String)) {\n            code = toString(code);\n        }\n\n        delegate = SyntaxTreeDelegate;\n        source = code;\n        index = 0;\n        lineNumber = (source.length > 0) ? 1 : 0;\n        lineStart = 0;\n        length = source.length;\n        lookahead = null;\n        state = {\n            allowKeyword: false,\n            allowIn: true,\n            labelSet: new StringMap(),\n            parenthesizedCount: 0,\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false,\n            inJSXChild: false,\n            inJSXTag: false,\n            inType: false,\n            lastCommentStart: -1,\n            yieldAllowed: false,\n            awaitAllowed: false,\n            curlyPosition: 0,\n            curlyStack: [],\n            curlyLastIndex: 0\n        };\n\n        extra = {};\n        if (typeof options !== 'undefined') {\n            extra.range = (typeof options.range === 'boolean') && options.range;\n            extra.loc = (typeof options.loc === 'boolean') && options.loc;\n            extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;\n\n            if (extra.loc && options.source !== null && options.source !== undefined) {\n                delegate = extend(delegate, {\n                    'postProcess': function (node) {\n                        node.loc.source = toString(options.source);\n                        return node;\n                    }\n                });\n            }\n\n            extra.sourceType = options.sourceType;\n            if (typeof options.tokens === 'boolean' && options.tokens) {\n                extra.tokens = [];\n            }\n            if (typeof options.comment === 'boolean' && options.comment) {\n                extra.comments = [];\n            }\n            if (typeof options.tolerant === 'boolean' && options.tolerant) {\n                extra.errors = [];\n            }\n            if (extra.attachComment) {\n                extra.range = true;\n                extra.comments = [];\n                extra.bottomRightStack = [];\n                extra.trailingComments = [];\n                extra.leadingComments = [];\n            }\n        }\n\n        patch();\n        try {\n            program = parseProgram();\n            if (typeof extra.comments !== 'undefined') {\n                program.comments = extra.comments;\n            }\n            if (typeof extra.tokens !== 'undefined') {\n                filterTokenLocation();\n                program.tokens = extra.tokens;\n            }\n            if (typeof extra.errors !== 'undefined') {\n                program.errors = extra.errors;\n            }\n        } catch (e) {\n            throw e;\n        } finally {\n            unpatch();\n            extra = {};\n        }\n\n        return program;\n    }\n\n    // Sync with *.json manifests.\n    exports.version = '15001.1001.0-dev-harmony-fb';\n\n    exports.tokenize = tokenize;\n\n    exports.parse = parse;\n\n    // Deep copy.\n   /* istanbul ignore next */\n    exports.Syntax = (function () {\n        var name, types = {};\n\n        if (typeof Object.create === 'function') {\n            types = Object.create(null);\n        }\n\n        for (name in Syntax) {\n            if (Syntax.hasOwnProperty(name)) {\n                types[name] = Syntax[name];\n            }\n        }\n\n        if (typeof Object.freeze === 'function') {\n            Object.freeze(types);\n        }\n\n        return types;\n    }());\n\n}));\n/* vim: set sw=4 ts=4 et tw=80 : */\n"]}