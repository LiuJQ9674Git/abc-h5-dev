{"version":3,"sources":["defs-main.js"],"names":[],"mappings":"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","file":"defs-main-compiled.js","sourcesContent":["\"use strict\";\n\nvar assert = require(\"assert\");\nvar is = require(\"simple-is\");\nvar fmt = require(\"simple-fmt\");\nvar stringmap = require(\"stringmap\");\nvar stringset = require(\"stringset\");\nvar alter = require(\"alter\");\nvar traverse = require(\"ast-traverse\");\nvar breakable = require(\"breakable\");\nvar Scope = require(\"./scope\");\nvar error = require(\"./error\");\nvar getline = error.getline;\nvar options = require(\"./options\");\nvar Stats = require(\"./stats\");\nvar jshint_vars = require(\"./jshint_globals/vars.js\");\n\n\nfunction isConstLet(kind) {\n    return is.someof(kind, [\"const\", \"let\"]);\n}\n\nfunction isVarConstLet(kind) {\n    return is.someof(kind, [\"var\", \"const\", \"let\"]);\n}\n\nfunction isNonFunctionBlock(node) {\n    return node.type === \"BlockStatement\" && is.noneof(node.$parent.type, [\"FunctionDeclaration\", \"FunctionExpression\"]);\n}\n\nfunction isForWithConstLet(node) {\n    return node.type === \"ForStatement\" && node.init && node.init.type === \"VariableDeclaration\" && isConstLet(node.init.kind);\n}\n\nfunction isForInOfWithConstLet(node) {\n    return isForInOf(node) && node.left.type === \"VariableDeclaration\" && isConstLet(node.left.kind);\n}\n\nfunction isForInOf(node) {\n    return is.someof(node.type, [\"ForInStatement\", \"ForOfStatement\"]);\n}\n\nfunction isFunction(node) {\n    return is.someof(node.type, [\"FunctionDeclaration\", \"FunctionExpression\"]);\n}\n\nfunction isLoop(node) {\n    return is.someof(node.type, [\"ForStatement\", \"ForInStatement\", \"ForOfStatement\", \"WhileStatement\", \"DoWhileStatement\"]);\n}\n\nfunction isReference(node) {\n    var parent = node.$parent;\n    return node.$refToScope ||\n        node.type === \"Identifier\" &&\n        !(parent.type === \"VariableDeclarator\" && parent.id === node) && // var|let|const $\n        !(parent.type === \"MemberExpression\" && parent.computed === false && parent.property === node) && // obj.$\n        !(parent.type === \"Property\" && parent.key === node) && // {$: ...}\n        !(parent.type === \"LabeledStatement\" && parent.label === node) && // $: ...\n        !(parent.type === \"CatchClause\" && parent.param === node) && // catch($)\n        !(isFunction(parent) && parent.id === node) && // function $(..\n        !(isFunction(parent) && is.someof(node, parent.params)) && // function f($)..\n        true;\n}\n\nfunction isLvalue(node) {\n    return isReference(node) &&\n        ((node.$parent.type === \"AssignmentExpression\" && node.$parent.left === node) ||\n            (node.$parent.type === \"UpdateExpression\" && node.$parent.argument === node));\n}\n\nfunction createScopes(node, parent) {\n    assert(!node.$scope);\n\n    node.$parent = parent;\n    node.$scope = node.$parent ? node.$parent.$scope : null; // may be overridden\n\n    if (node.type === \"Program\") {\n        // Top-level program is a scope\n        // There's no block-scope under it\n        node.$scope = new Scope({\n            kind: \"hoist\",\n            node: node,\n            parent: null,\n        });\n\n    } else if (isFunction(node)) {\n        // Function is a scope, with params in it\n        // There's no block-scope under it\n\n        node.$scope = new Scope({\n            kind: \"hoist\",\n            node: node,\n            parent: node.$parent.$scope,\n        });\n\n        // function has a name\n        if (node.id) {\n            assert(node.id.type === \"Identifier\");\n\n            if (node.type === \"FunctionDeclaration\") {\n                // Function name goes in parent scope for declared functions\n                node.$parent.$scope.add(node.id.name, \"fun\", node.id, null);\n            } else if (node.type === \"FunctionExpression\") {\n                // Function name goes in function's scope for named function expressions\n                node.$scope.add(node.id.name, \"fun\", node.id, null);\n            } else {\n                assert(false);\n            }\n        }\n\n        node.params.forEach(function(param) {\n            node.$scope.add(param.name, \"param\", param, null);\n        });\n\n    } else if (node.type === \"VariableDeclaration\") {\n        // Variable declarations names goes in current scope\n        assert(isVarConstLet(node.kind));\n        node.declarations.forEach(function(declarator) {\n            assert(declarator.type === \"VariableDeclarator\");\n            var name = declarator.id.name;\n            if (options.disallowVars && node.kind === \"var\") {\n                error(getline(declarator), \"var {0} is not allowed (use let or const)\", name);\n            }\n            node.$scope.add(name, node.kind, declarator.id, declarator.range[1]);\n        });\n\n    } else if (isForWithConstLet(node) || isForInOfWithConstLet(node)) {\n        // For(In/Of) loop with const|let declaration is a scope, with declaration in it\n        // There may be a block-scope under it\n        node.$scope = new Scope({\n            kind: \"block\",\n            node: node,\n            parent: node.$parent.$scope,\n        });\n\n    } else if (isNonFunctionBlock(node)) {\n        // A block node is a scope unless parent is a function\n        node.$scope = new Scope({\n            kind: \"block\",\n            node: node,\n            parent: node.$parent.$scope,\n        });\n\n    } else if (node.type === \"CatchClause\") {\n        var identifier = node.param;\n\n        node.$scope = new Scope({\n            kind: \"catch-block\",\n            node: node,\n            parent: node.$parent.$scope,\n        });\n        node.$scope.add(identifier.name, \"caught\", identifier, null);\n\n        // All hoist-scope keeps track of which variables that are propagated through,\n        // i.e. an reference inside the scope points to a declaration outside the scope.\n        // This is used to mark \"taint\" the name since adding a new variable in the scope,\n        // with a propagated name, would change the meaning of the existing references.\n        //\n        // catch(e) is special because even though e is a variable in its own scope,\n        // we want to make sure that catch(e){let e} is never transformed to\n        // catch(e){var e} (but rather var e$0). For that reason we taint the use of e\n        // in the closest hoist-scope, i.e. where var e$0 belongs.\n        node.$scope.closestHoistScope().markPropagates(identifier.name);\n    }\n}\n\nfunction createTopScope(programScope, environments, globals) {\n    function inject(obj) {\n        for (var name in obj) {\n            var writeable = obj[name];\n            var kind = (writeable ? \"var\" : \"const\");\n            if (topScope.hasOwn(name)) {\n                topScope.remove(name);\n            }\n            topScope.add(name, kind, {loc: {start: {line: -1}}}, -1);\n        }\n    }\n\n    var topScope = new Scope({\n        kind: \"hoist\",\n        node: {},\n        parent: null,\n    });\n\n    var complementary = {\n        undefined: false,\n        Infinity: false,\n        console: false,\n    };\n\n    inject(complementary);\n    inject(jshint_vars.reservedVars);\n    inject(jshint_vars.ecmaIdentifiers);\n    if (environments) {\n        environments.forEach(function(env) {\n            if (!jshint_vars[env]) {\n                error(-1, 'environment \"{0}\" not found', env);\n            } else {\n                inject(jshint_vars[env]);\n            }\n        });\n    }\n    if (globals) {\n        inject(globals);\n    }\n\n    // link it in\n    programScope.parent = topScope;\n    topScope.children.push(programScope);\n\n    return topScope;\n}\n\nfunction setupReferences(ast, allIdentifiers, opts) {\n    var analyze = (is.own(opts, \"analyze\") ? opts.analyze : true);\n\n    function visit(node) {\n        if (!isReference(node)) {\n            return;\n        }\n        allIdentifiers.add(node.name);\n\n        var scope = node.$scope.lookup(node.name);\n        if (analyze && !scope && options.disallowUnknownReferences) {\n            error(getline(node), \"reference to unknown global variable {0}\", node.name);\n        }\n        // check const and let for referenced-before-declaration\n        if (analyze && scope && is.someof(scope.getKind(node.name), [\"const\", \"let\"])) {\n            var allowedFromPos = scope.getFromPos(node.name);\n            var referencedAtPos = node.range[0];\n            assert(is.finitenumber(allowedFromPos));\n            assert(is.finitenumber(referencedAtPos));\n            if (referencedAtPos < allowedFromPos) {\n                if (!node.$scope.hasFunctionScopeBetween(scope)) {\n                    error(getline(node), \"{0} is referenced before its declaration\", node.name);\n                }\n            }\n        }\n        node.$refToScope = scope;\n    }\n\n    traverse(ast, {pre: visit});\n}\n\n// TODO for loops init and body props are parallel to each other but init scope is outer that of body\n// TODO is this a problem?\n\nfunction varify(ast, stats, allIdentifiers, changes) {\n    function unique(name) {\n        assert(allIdentifiers.has(name));\n        for (var cnt = 0; ; cnt++) {\n            var genName = name + \"$\" + String(cnt);\n            if (!allIdentifiers.has(genName)) {\n                return genName;\n            }\n        }\n    }\n\n    function renameDeclarations(node) {\n        if (node.type === \"VariableDeclaration\" && isConstLet(node.kind)) {\n            var hoistScope = node.$scope.closestHoistScope();\n            var origScope = node.$scope;\n\n            // text change const|let => var\n            changes.push({\n                start: node.range[0],\n                end: node.range[0] + node.kind.length,\n                str: \"var\",\n            });\n\n            node.declarations.forEach(function(declarator) {\n                assert(declarator.type === \"VariableDeclarator\");\n                var name = declarator.id.name;\n\n                stats.declarator(node.kind);\n\n                // rename if\n                // 1) name already exists in hoistScope, or\n                // 2) name is already propagated (passed) through hoistScope or manually tainted\n                var rename = (origScope !== hoistScope &&\n                    (hoistScope.hasOwn(name) || hoistScope.doesPropagate(name)));\n\n                var newName = (rename ? unique(name) : name);\n\n                origScope.remove(name);\n                hoistScope.add(newName, \"var\", declarator.id, declarator.range[1]);\n\n                origScope.moves = origScope.moves || stringmap();\n                origScope.moves.set(name, {\n                    name: newName,\n                    scope: hoistScope,\n                });\n\n                allIdentifiers.add(newName);\n\n                if (newName !== name) {\n                    stats.rename(name, newName, getline(declarator));\n\n                    declarator.id.originalName = name;\n                    declarator.id.name = newName;\n\n                    // textchange var x => var x$1\n                    changes.push({\n                        start: declarator.id.range[0],\n                        end: declarator.id.range[1],\n                        str: newName,\n                    });\n                }\n            });\n\n            // ast change const|let => var\n            node.kind = \"var\";\n        }\n    }\n\n    function renameReferences(node) {\n        if (!node.$refToScope) {\n            return;\n        }\n        var move = node.$refToScope.moves && node.$refToScope.moves.get(node.name);\n        if (!move) {\n            return;\n        }\n        node.$refToScope = move.scope;\n\n        if (node.name !== move.name) {\n            node.originalName = node.name;\n            node.name = move.name;\n\n            if (node.alterop) {\n                // node has no range because it is the result of another alter operation\n                var existingOp = null;\n                for (var i = 0; i < changes.length; i++) {\n                    var op = changes[i];\n                    if (op.node === node) {\n                        existingOp = op;\n                        break;\n                    }\n                }\n                assert(existingOp);\n\n                // modify op\n                existingOp.str = move.name;\n            } else {\n                changes.push({\n                    start: node.range[0],\n                    end: node.range[1],\n                    str: move.name,\n                });\n            }\n        }\n    }\n\n    traverse(ast, {pre: renameDeclarations});\n    traverse(ast, {pre: renameReferences});\n    ast.$scope.traverse({pre: function(scope) {\n        delete scope.moves;\n    }});\n}\n\n\nfunction detectLoopClosures(ast) {\n    traverse(ast, {pre: visit});\n\n    function detectIifyBodyBlockers(body, node) {\n        return breakable(function(brk) {\n            traverse(body, {pre: function(n) {\n                // if we hit an inner function of the loop body, don't traverse further\n                if (isFunction(n)) {\n                    return false;\n                }\n\n                var err = true; // reset to false in else-statement below\n                var msg = \"loop-variable {0} is captured by a loop-closure that can't be transformed due to use of {1} at line {2}\";\n                if (n.type === \"BreakStatement\") {\n                    error(getline(node), msg, node.name, \"break\", getline(n));\n                } else if (n.type === \"ContinueStatement\") {\n                    error(getline(node), msg, node.name, \"continue\", getline(n));\n                } else if (n.type === \"ReturnStatement\") {\n                    error(getline(node), msg, node.name, \"return\", getline(n));\n                } else if (n.type === \"YieldExpression\") {\n                    error(getline(node), msg, node.name, \"yield\", getline(n));\n                } else if (n.type === \"Identifier\" && n.name === \"arguments\") {\n                    error(getline(node), msg, node.name, \"arguments\", getline(n));\n                } else if (n.type === \"VariableDeclaration\" && n.kind === \"var\") {\n                    error(getline(node), msg, node.name, \"var\", getline(n));\n                } else {\n                    err = false;\n                }\n                if (err) {\n                    brk(true); // break traversal\n                }\n            }});\n            return false;\n        });\n    }\n\n    function visit(node) {\n        // forbidden pattern:\n        // <any>* <loop> <non-fn>* <constlet-def> <any>* <fn> <any>* <constlet-ref>\n        var loopNode = null;\n        if (isReference(node) && node.$refToScope && isConstLet(node.$refToScope.getKind(node.name))) {\n            // traverse nodes up towards root from constlet-def\n            // if we hit a function (before a loop) - ok!\n            // if we hit a loop - maybe-ouch\n            // if we reach root - ok!\n            for (var n = node.$refToScope.node; ; ) {\n                if (isFunction(n)) {\n                    // we're ok (function-local)\n                    return;\n                } else if (isLoop(n)) {\n                    loopNode = n;\n                    // maybe not ok (between loop and function)\n                    break;\n                }\n                n = n.$parent;\n                if (!n) {\n                    // ok (reached root)\n                    return;\n                }\n            }\n\n            assert(isLoop(loopNode));\n\n            // traverse scopes from reference-scope up towards definition-scope\n            // if we hit a function, ouch!\n            var defScope = node.$refToScope;\n            var generateIIFE = (options.loopClosures === \"iife\");\n\n            for (var s = node.$scope; s; s = s.parent) {\n                if (s === defScope) {\n                    // we're ok\n                    return;\n                } else if (isFunction(s.node)) {\n                    // not ok (there's a function between the reference and definition)\n                    // may be transformable via IIFE\n\n                    if (!generateIIFE) {\n                        var msg = \"loop-variable {0} is captured by a loop-closure. Tried \\\"loopClosures\\\": \\\"iife\\\" in defs-config.json?\";\n                        return error(getline(node), msg, node.name);\n                    }\n\n                    // here be dragons\n                    // for (let x = ..; .. ; ..) { (function(){x})() } is forbidden because of current\n                    // spec and VM status\n                    if (loopNode.type === \"ForStatement\" && defScope.node === loopNode) {\n                        var declarationNode = defScope.getNode(node.name);\n                        return error(getline(declarationNode), \"Not yet specced ES6 feature. {0} is declared in for-loop header and then captured in loop closure\", declarationNode.name);\n                    }\n\n                    // speak now or forever hold your peace\n                    if (detectIifyBodyBlockers(loopNode.body, node)) {\n                        // error already generated\n                        return;\n                    }\n\n                    // mark loop for IIFE-insertion\n                    loopNode.$iify = true;\n                }\n            }\n        }\n    }\n}\n\nfunction transformLoopClosures(root, ops, options) {\n    function insertOp(pos, str, node) {\n        var op = {\n            start: pos,\n            end: pos,\n            str: str,\n        }\n        if (node) {\n            op.node = node;\n        }\n        ops.push(op);\n    }\n\n    traverse(root, {pre: function(node) {\n        if (!node.$iify) {\n            return;\n        }\n\n        var hasBlock = (node.body.type === \"BlockStatement\");\n\n        var insertHead = (hasBlock ?\n            node.body.range[0] + 1 : // just after body {\n            node.body.range[0]); // just before existing expression\n        var insertFoot = (hasBlock ?\n            node.body.range[1] - 1 : // just before body }\n            node.body.range[1]);  // just after existing expression\n\n        var forInName = (isForInOf(node) && node.left.declarations[0].id.name);;\n        var iifeHead = fmt(\"(function({0}){\", forInName ? forInName : \"\");\n        var iifeTail = fmt(\"}).call(this{0});\", forInName ? \", \" + forInName : \"\");\n\n        // modify AST\n        var iifeFragment = options.parse(iifeHead + iifeTail);\n        var iifeExpressionStatement = iifeFragment.body[0];\n        var iifeBlockStatement = iifeExpressionStatement.expression.callee.object.body;\n\n        if (hasBlock) {\n            var forBlockStatement = node.body;\n            var tmp = forBlockStatement.body;\n            forBlockStatement.body = [iifeExpressionStatement];\n            iifeBlockStatement.body = tmp;\n        } else {\n            var tmp$0 = node.body;\n            node.body = iifeExpressionStatement;\n            iifeBlockStatement.body[0] = tmp$0;\n        }\n\n        // create ops\n        insertOp(insertHead, iifeHead);\n\n        if (forInName) {\n            insertOp(insertFoot, \"}).call(this, \");\n\n            var args = iifeExpressionStatement.expression.arguments;\n            var iifeArgumentIdentifier = args[1];\n            iifeArgumentIdentifier.alterop = true;\n            insertOp(insertFoot, forInName, iifeArgumentIdentifier);\n\n            insertOp(insertFoot, \");\");\n        } else {\n            insertOp(insertFoot, iifeTail);\n        }\n    }});\n}\n\nfunction detectConstAssignment(ast) {\n    traverse(ast, {pre: function(node) {\n        if (isLvalue(node)) {\n            var scope = node.$scope.lookup(node.name);\n            if (scope && scope.getKind(node.name) === \"const\") {\n                error(getline(node), \"can't assign to const variable {0}\", node.name);\n            }\n        }\n    }});\n}\n\nfunction detectConstantLets(ast) {\n    traverse(ast, {pre: function(node) {\n        if (isLvalue(node)) {\n            var scope = node.$scope.lookup(node.name);\n            if (scope) {\n                scope.markWrite(node.name);\n            }\n        }\n    }});\n\n    ast.$scope.detectUnmodifiedLets();\n}\n\nfunction setupScopeAndReferences(root, opts) {\n    // setup scopes\n    traverse(root, {pre: createScopes});\n    var topScope = createTopScope(root.$scope, options.environments, options.globals);\n\n    // allIdentifiers contains all declared and referenced vars\n    // collect all declaration names (including those in topScope)\n    var allIdentifiers = stringset();\n    topScope.traverse({pre: function(scope) {\n        allIdentifiers.addMany(scope.decls.keys());\n    }});\n\n    // setup node.$refToScope, check for errors.\n    // also collects all referenced names to allIdentifiers\n    setupReferences(root, allIdentifiers, opts);\n    return allIdentifiers;\n}\n\nfunction cleanupTree(root) {\n    traverse(root, {pre: function(node) {\n        for (var prop in node) {\n            if (prop[0] === \"$\") {\n                delete node[prop];\n            }\n        }\n    }});\n}\n\nfunction run(src, config) {\n    // alter the options singleton with user configuration\n    for (var key in config) {\n        options[key] = config[key];\n    }\n\n    var parsed;\n\n    if (is.object(src)) {\n        if (!options.ast) {\n            return {\n                errors: [\n                    \"Can't produce string output when input is an AST. \" +\n                    \"Did you forget to set options.ast = true?\"\n                ],\n            };\n        }\n\n        // Received an AST object as src, so no need to parse it.\n        parsed = src;\n\n    } else if (is.string(src)) {\n        try {\n            parsed = options.parse(src, {\n                loc: true,\n                range: true,\n            });\n        } catch (e) {\n            return {\n                errors: [\n                    fmt(\"line {0} column {1}: Error during input file parsing\\n{2}\\n{3}\",\n                        e.lineNumber,\n                        e.column,\n                        src.split(\"\\n\")[e.lineNumber - 1],\n                        fmt.repeat(\" \", e.column - 1) + \"^\")\n                ],\n            };\n        }\n\n    } else {\n        return {\n            errors: [\"Input was neither an AST object nor a string.\"],\n        };\n    }\n\n    var ast = parsed;\n\n    // TODO detect unused variables (never read)\n    error.reset();\n\n    var allIdentifiers = setupScopeAndReferences(ast, {});\n\n    // static analysis passes\n    detectLoopClosures(ast);\n    detectConstAssignment(ast);\n    //detectConstantLets(ast);\n\n    var changes = [];\n    transformLoopClosures(ast, changes, options);\n\n    //ast.$scope.print(); process.exit(-1);\n\n    if (error.errors.length >= 1) {\n        return {\n            errors: error.errors,\n        };\n    }\n\n    if (changes.length > 0) {\n        cleanupTree(ast);\n        allIdentifiers = setupScopeAndReferences(ast, {analyze: false});\n    }\n    assert(error.errors.length === 0);\n\n    // change constlet declarations to var, renamed if needed\n    // varify modifies the scopes and AST accordingly and\n    // returns a list of change fragments (to use with alter)\n    var stats = new Stats();\n    varify(ast, stats, allIdentifiers, changes);\n\n    if (options.ast) {\n        // return the modified AST instead of src code\n        // get rid of all added $ properties first, such as $parent and $scope\n        cleanupTree(ast);\n        return {\n            stats: stats,\n            ast: ast,\n        };\n    } else {\n        // apply changes produced by varify and return the transformed src\n        var transformedSrc = alter(src, changes);\n        return {\n            stats: stats,\n            src: transformedSrc,\n        };\n    }\n}\n\nmodule.exports = run;\n"]}