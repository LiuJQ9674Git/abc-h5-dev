{"version":3,"sources":["forbidden-loop-closure.js"],"names":[],"mappings":"AAAA;;AACA,IAAI,MAAM,EAAV;;;;;;;;;AASA,KAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,CAApB,EAAuB,GAAvB,EAA4B;AACxB,QAAI,IAAJ,CAAS,YAAW;AAAE,eAAO,CAAP;AAAW,KAAjC;AACH;AACD,KAAK,IAAI,CAAJ,EAAO,IAAI,CAAhB,EAAmB,IAAI,CAAvB,EAA0B,GAA1B,EAA+B;AAC3B,QAAI,IAAJ,CAAS,YAAW;AAAE,eAAO,CAAP;AAAW,KAAjC;AACH;;;;;;AAMD,KAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,CAApB,EAAuB,GAAvB,EAA4B;AAAC,KAAC,YAAU;AACpC,YAAI,IAAI,CAAR;AACA,YAAI,IAAJ,CAAS,YAAW;AAAE,mBAAO,CAAP;AAAW,SAAjC;AACH,KAH4B,EAG1B,IAH0B,CAGrB,IAHqB;AAGd;;;AAGf,CAAC,YAAW;AACR,SAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,CAApB,EAAuB,GAAvB,EAA4B;AACxB,YAAI,IAAI,CAAR;AACA,eAAO,CAAP;AACA,YAAI,IAAJ,CAAS,YAAW;AAAE,mBAAO,CAAP;AAAW,SAAjC;AACH;AACJ,CAND;;;AASA,KAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,CAApB,EAAuB,GAAvB,EAA4B;AACxB,QAAI,IAAI,CAAR;AACA;AACA,QAAI,IAAJ,CAAS,YAAW;AAAE,eAAO,CAAP;AAAW,KAAjC;AACH;;;AAGD,KAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,CAApB,EAAuB,GAAvB,EAA4B;AACxB,QAAI,IAAI,CAAR;AACA;AACA,QAAI,IAAJ,CAAS,YAAW;AAAE,eAAO,CAAP;AAAW,KAAjC;AACH;;;;AAID,KAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,CAApB,EAAuB,GAAvB,EAA4B;AACxB,QAAI,IAAI,CAAR;AACA,cAAU,CAAV;AACA,QAAI,IAAJ,CAAS,YAAW;AAAE,eAAO,CAAP;AAAW,KAAjC;AACH;;;AAGD,KAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,CAApB,EAAuB,GAAvB,EAA4B;AACxB,QAAI,IAAI,CAAR;AACA,QAAI,IAAI,CAAR;AACA,QAAI,IAAJ,CAAS,YAAW;AAAE,eAAO,CAAP;AAAW,KAAjC;AACH;;;;AAID,IAAI,OAAJ,CAAY,UAAS,CAAT,EAAY;AACpB,YAAQ,GAAR,CAAY,GAAZ;AACH,CAFD","file":"forbidden-loop-closure-compiled.js","sourcesContent":["\"use strict\";\nvar arr = [];\n\n// fresh x per iteration but semantics not determined yet\n// in ES6 spec draft (transfer in particular). Also inconsistent\n// between VM implementations.\n// once ES6 nails down the semantics (and VM's catch up) we'll\n// revisit\n// note v8 bug https://code.google.com/p/v8/issues/detail?id=2560\n// also see other/v8-bug.js\nfor (let x = 0; x < 3; x++) {\n    arr.push(function() { return x; });\n}\nfor (let z, x = 0; x < 3; x++) {\n    arr.push(function() { return x; });\n}\n\n// as a consequence of the above, defs is unable to transform\n// the code below (even though it is the output of an earlier\n// defs transformation). we should be able to detect this case\n// (and pass it through unmodified) but is it worth the effort?\nfor (let x = 0; x < 3; x++) {(function(){\n    let y = x;\n    arr.push(function() { return y; });\n}).call(this);}\n\n// return is not allowed inside the loop body because the IIFE would break it\n(function() {\n    for (let x = 0; x < 3; x++) {\n        let y = x;\n        return 1;\n        arr.push(function() { return y; });\n    }\n})();\n\n// break is not allowed inside the loop body because the IIFE would break it\nfor (let x = 0; x < 3; x++) {\n    let y = x;\n    break;\n    arr.push(function() { return y; });\n}\n\n// continue is not allowed inside the loop body because the IIFE would break it\nfor (let x = 0; x < 3; x++) {\n    let y = x;\n    continue;\n    arr.push(function() { return y; });\n}\n\n// arguments is not allowed inside the loop body because the IIFE would break it\n// (and I don't want to re-apply outer arguments in the inserted IIFE)\nfor (let x = 0; x < 3; x++) {\n    let y = x;\n    arguments[0];\n    arr.push(function() { return y; });\n}\n\n// continue is not allowed inside the loop body because the IIFE would break it\nfor (let x = 0; x < 3; x++) {\n    let y = x;\n    var z = 1;\n    arr.push(function() { return y; });\n}\n\n// TODO block-less loops (is that even applicable?)\n\narr.forEach(function(f) {\n    console.log(f());\n});\n"]}