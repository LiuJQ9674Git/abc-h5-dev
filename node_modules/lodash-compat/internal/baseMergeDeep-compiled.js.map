{"version":3,"sources":["baseMergeDeep.js"],"names":[],"mappings":"AAAA,IAAI,YAAY,QAAQ,aAAR,CAAhB;IACI,cAAc,QAAQ,qBAAR,CADlB;IAEI,UAAU,QAAQ,iBAAR,CAFd;IAGI,cAAc,QAAQ,eAAR,CAHlB;IAII,gBAAgB,QAAQ,uBAAR,CAJpB;IAKI,eAAe,QAAQ,sBAAR,CALnB;IAMI,gBAAgB,QAAQ,uBAAR,CANpB;;;;;;;;;;;;;;;;;AAuBA,SAAS,aAAT,CAAuB,MAAvB,EAA+B,MAA/B,EAAuC,GAAvC,EAA4C,SAA5C,EAAuD,UAAvD,EAAmE,MAAnE,EAA2E,MAA3E,EAAmF;AACjF,MAAI,SAAS,OAAO,MAApB;MACI,WAAW,OAAO,GAAP,CADf;;AAGA,SAAO,QAAP,EAAiB;AACf,QAAI,OAAO,MAAP,KAAkB,QAAtB,EAAgC;AAC9B,aAAO,GAAP,IAAc,OAAO,MAAP,CAAd;AACA;AACD;AACF;AACD,MAAI,QAAQ,OAAO,GAAP,CAAZ;MACI,SAAS,aAAa,WAAW,KAAX,EAAkB,QAAlB,EAA4B,GAA5B,EAAiC,MAAjC,EAAyC,MAAzC,CAAb,GAAgE,SAD7E;MAEI,WAAW,WAAW,SAF1B;;AAIA,MAAI,QAAJ,EAAc;AACZ,aAAS,QAAT;AACA,QAAI,YAAY,QAAZ,MAA0B,QAAQ,QAAR,KAAqB,aAAa,QAAb,CAA/C,CAAJ,EAA4E;AAC1E,eAAS,QAAQ,KAAR,IACL,KADK,GAEJ,YAAY,KAAZ,IAAqB,UAAU,KAAV,CAArB,GAAwC,EAF7C;AAGD,KAJD,MAKK,IAAI,cAAc,QAAd,KAA2B,YAAY,QAAZ,CAA/B,EAAsD;AACzD,eAAS,YAAY,KAAZ,IACL,cAAc,KAAd,CADK,GAEJ,cAAc,KAAd,IAAuB,KAAvB,GAA+B,EAFpC;AAGD,KAJI,MAKA;AACH,iBAAW,KAAX;AACD;AACF;;;AAGD,SAAO,IAAP,CAAY,QAAZ;AACA,SAAO,IAAP,CAAY,MAAZ;;AAEA,MAAI,QAAJ,EAAc;;AAEZ,WAAO,GAAP,IAAc,UAAU,MAAV,EAAkB,QAAlB,EAA4B,UAA5B,EAAwC,MAAxC,EAAgD,MAAhD,CAAd;AACD,GAHD,MAGO,IAAI,WAAW,MAAX,GAAqB,WAAW,KAAhC,GAA0C,UAAU,KAAxD,EAAgE;AACrE,WAAO,GAAP,IAAc,MAAd;AACD;AACF;;AAED,OAAO,OAAP,GAAiB,aAAjB","file":"baseMergeDeep-compiled.js","sourcesContent":["var arrayCopy = require('./arrayCopy'),\n    isArguments = require('../lang/isArguments'),\n    isArray = require('../lang/isArray'),\n    isArrayLike = require('./isArrayLike'),\n    isPlainObject = require('../lang/isPlainObject'),\n    isTypedArray = require('../lang/isTypedArray'),\n    toPlainObject = require('../lang/toPlainObject');\n\n/**\n * A specialized version of `baseMerge` for arrays and objects which performs\n * deep merges and tracks traversed objects enabling objects with circular\n * references to be merged.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {string} key The key of the value to merge.\n * @param {Function} mergeFunc The function to merge values.\n * @param {Function} [customizer] The function to customize merged values.\n * @param {Array} [stackA=[]] Tracks traversed source objects.\n * @param {Array} [stackB=[]] Associates values with source counterparts.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {\n  var length = stackA.length,\n      srcValue = source[key];\n\n  while (length--) {\n    if (stackA[length] == srcValue) {\n      object[key] = stackB[length];\n      return;\n    }\n  }\n  var value = object[key],\n      result = customizer ? customizer(value, srcValue, key, object, source) : undefined,\n      isCommon = result === undefined;\n\n  if (isCommon) {\n    result = srcValue;\n    if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {\n      result = isArray(value)\n        ? value\n        : (isArrayLike(value) ? arrayCopy(value) : []);\n    }\n    else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n      result = isArguments(value)\n        ? toPlainObject(value)\n        : (isPlainObject(value) ? value : {});\n    }\n    else {\n      isCommon = false;\n    }\n  }\n  // Add the source value to the stack of traversed objects and associate\n  // it with its merged value.\n  stackA.push(srcValue);\n  stackB.push(result);\n\n  if (isCommon) {\n    // Recursively merge objects and arrays (susceptible to call stack limits).\n    object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);\n  } else if (result === result ? (result !== value) : (value === value)) {\n    object[key] = result;\n  }\n}\n\nmodule.exports = baseMergeDeep;\n"]}