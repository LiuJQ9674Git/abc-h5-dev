{"version":3,"sources":["binaryIndexBy.js"],"names":[],"mappings":";AACA,IAAI,cAAc,KAAK,KAAvB;IACI,YAAY,KAAK,GADrB;;;AAIA,IAAI,mBAAmB,UAAvB;IACI,kBAAkB,mBAAmB,CADzC;;;;;;;;;;;;;;;AAgBA,SAAS,aAAT,CAAuB,KAAvB,EAA8B,KAA9B,EAAqC,QAArC,EAA+C,UAA/C,EAA2D;AACzD,UAAQ,SAAS,KAAT,CAAR;;AAEA,MAAI,MAAM,CAAV;MACI,OAAO,QAAQ,MAAM,MAAd,GAAuB,CADlC;MAEI,WAAW,UAAU,KAFzB;MAGI,YAAY,UAAU,IAH1B;MAII,aAAa,UAAU,SAJ3B;;AAMA,SAAO,MAAM,IAAb,EAAmB;AACjB,QAAI,MAAM,YAAY,CAAC,MAAM,IAAP,IAAe,CAA3B,CAAV;QACI,WAAW,SAAS,MAAM,GAAN,CAAT,CADf;QAEI,QAAQ,aAAa,SAFzB;QAGI,cAAc,aAAa,QAH/B;;AAKA,QAAI,QAAJ,EAAc;AACZ,UAAI,SAAS,eAAe,UAA5B;AACD,KAFD,MAEO,IAAI,SAAJ,EAAe;AACpB,eAAS,eAAe,KAAf,KAAyB,cAAc,YAAY,IAAnD,CAAT;AACD,KAFM,MAEA,IAAI,UAAJ,EAAgB;AACrB,eAAS,gBAAgB,cAAc,KAA9B,CAAT;AACD,KAFM,MAEA,IAAI,YAAY,IAAhB,EAAsB;AAC3B,eAAS,KAAT;AACD,KAFM,MAEA;AACL,eAAS,aAAc,YAAY,KAA1B,GAAoC,WAAW,KAAxD;AACD;AACD,QAAI,MAAJ,EAAY;AACV,YAAM,MAAM,CAAZ;AACD,KAFD,MAEO;AACL,aAAO,GAAP;AACD;AACF;AACD,SAAO,UAAU,IAAV,EAAgB,eAAhB,CAAP;AACD;;AAED,OAAO,OAAP,GAAiB,aAAjB","file":"binaryIndexBy-compiled.js","sourcesContent":["/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeFloor = Math.floor,\n    nativeMin = Math.min;\n\n/** Used as references for the maximum length and index of an array. */\nvar MAX_ARRAY_LENGTH = 4294967295,\n    MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1;\n\n/**\n * This function is like `binaryIndex` except that it invokes `iteratee` for\n * `value` and each element of `array` to compute their sort ranking. The\n * iteratee is invoked with one argument; (value).\n *\n * @private\n * @param {Array} array The sorted array to inspect.\n * @param {*} value The value to evaluate.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {boolean} [retHighest] Specify returning the highest qualified index.\n * @returns {number} Returns the index at which `value` should be inserted\n *  into `array`.\n */\nfunction binaryIndexBy(array, value, iteratee, retHighest) {\n  value = iteratee(value);\n\n  var low = 0,\n      high = array ? array.length : 0,\n      valIsNaN = value !== value,\n      valIsNull = value === null,\n      valIsUndef = value === undefined;\n\n  while (low < high) {\n    var mid = nativeFloor((low + high) / 2),\n        computed = iteratee(array[mid]),\n        isDef = computed !== undefined,\n        isReflexive = computed === computed;\n\n    if (valIsNaN) {\n      var setLow = isReflexive || retHighest;\n    } else if (valIsNull) {\n      setLow = isReflexive && isDef && (retHighest || computed != null);\n    } else if (valIsUndef) {\n      setLow = isReflexive && (retHighest || isDef);\n    } else if (computed == null) {\n      setLow = false;\n    } else {\n      setLow = retHighest ? (computed <= value) : (computed < value);\n    }\n    if (setLow) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return nativeMin(high, MAX_ARRAY_INDEX);\n}\n\nmodule.exports = binaryIndexBy;\n"]}